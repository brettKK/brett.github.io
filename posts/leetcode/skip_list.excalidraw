{
  "type": "excalidraw",
  "version": 2,
  "source": "http://localhost:3000",
  "elements": [
    {
      "id": "NZrHTAvAENZ1v4KuIz7Sb",
      "type": "text",
      "x": 394,
      "y": 114,
      "width": 289,
      "height": 1060,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 2043651252,
      "version": 768,
      "versionNonce": 832725044,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659603504805,
      "link": null,
      "locked": false,
      "text": "type Node struct {\n    value uint32\n    levels []*Level\n}\ntype Level struct {\n    next *Node\n}\ntype SkipList struct {\n    header *Node\n    height uint32\n    length uint32\n}\nvar {\n    p = 0.5\n    MaxLevel = 32\n}\nfunc NewSkipList() *SkipList {\n    return &SkipList {\n        header: NewNode(MaxLevel, 0);\n        height: 1;\n        length: 0;\n    }\n}\nfunc NewNode(levels, value uint32) *Node {\n    node := new(Node)\n    node.value = value\n    node.levels = make([]*Level, levels)\n    for i := 0; i < levels; i++ {\n        node.levels[i] = new(Level)\n    }\n    return node\n}\nfunc (sl *SkipList) randomLevel() int {\n    level := 1\n    r := rand.New()\n    for r.Float64() < p && level < MaxLevel {\n        level++\n    }\n    return level\n}",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 1055,
      "containerId": null,
      "originalText": "type Node struct {\n    value uint32\n    levels []*Level\n}\ntype Level struct {\n    next *Node\n}\ntype SkipList struct {\n    header *Node\n    height uint32\n    length uint32\n}\nvar {\n    p = 0.5\n    MaxLevel = 32\n}\nfunc NewSkipList() *SkipList {\n    return &SkipList {\n        header: NewNode(MaxLevel, 0);\n        height: 1;\n        length: 0;\n    }\n}\nfunc NewNode(levels, value uint32) *Node {\n    node := new(Node)\n    node.value = value\n    node.levels = make([]*Level, levels)\n    for i := 0; i < levels; i++ {\n        node.levels[i] = new(Level)\n    }\n    return node\n}\nfunc (sl *SkipList) randomLevel() int {\n    level := 1\n    r := rand.New()\n    for r.Float64() < p && level < MaxLevel {\n        level++\n    }\n    return level\n}"
    },
    {
      "id": "u1oc4mmDZUO51-NUbQOBi",
      "type": "text",
      "x": 820,
      "y": 118.4140625,
      "width": 655,
      "height": 1007,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 101349260,
      "version": 1657,
      "versionNonce": 2101499188,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659600635271,
      "link": null,
      "locked": false,
      "text": "func (sl *SkipList) Add(value uint32) bool {\n    //  每一层最后一个比value 小的节点\n    // 每一层的插入位置\n    update := make([]*Node, MaxLevel)\n    tmp := sl.header\n    // 从最高层开始查询 插入位置\n    for i := sl.height - 1; i >= 0; i-- {\n         // 遍历完一层后，下一层的起始查找位置为上一层tmp之后        \n        for tmp.levels[i] != nil && tmp.levels[i].next != nil && tmp.levels[i].next.value < value {\n            tmp = tmp.levels[i].next\n        }\n        if tmp.levels[i].next != nil && tmp.levels[i].next.value == value {\n            return false\n        }\n        // 找到第i层的插入位置为tmp，放入update中\n        update[i] = tmp\n        // 遍历完一层后，下一层的起始查找位置一定在上一层tmp之后        \n    }\n    level := sl.randomLevel()\n    node := NewNode(uint32(level), value)1\n    if uint32(level) > sl.height {\n        sl.height = uint32(level)\n    }\n    // 从 0- level层的链表均需要更新， level+1 ～ height之间的上层链表不用更新\n    for i := 0; i < level; i++ {\n        // 新节点超过height，将头节点对应层数的后继节点设置为新节点 \n        if update[i] == nil {\n            sl.header.levels[i].next = node\n            continue\n        }\n        // 修改新节点的后继节点为\n        node.levels[i].next = update[i].levels[i].next\n        // 修改每一层最后一个比value 小的节点的后继节点为新节点\n        update[i].levels[i].next = node\n    }\n    sl.length++\n    return true\n}",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 1002,
      "containerId": null,
      "originalText": "func (sl *SkipList) Add(value uint32) bool {\n    //  每一层最后一个比value 小的节点\n    // 每一层的插入位置\n    update := make([]*Node, MaxLevel)\n    tmp := sl.header\n    // 从最高层开始查询 插入位置\n    for i := sl.height - 1; i >= 0; i-- {\n         // 遍历完一层后，下一层的起始查找位置为上一层tmp之后        \n        for tmp.levels[i] != nil && tmp.levels[i].next != nil && tmp.levels[i].next.value < value {\n            tmp = tmp.levels[i].next\n        }\n        if tmp.levels[i].next != nil && tmp.levels[i].next.value == value {\n            return false\n        }\n        // 找到第i层的插入位置为tmp，放入update中\n        update[i] = tmp\n        // 遍历完一层后，下一层的起始查找位置一定在上一层tmp之后        \n    }\n    level := sl.randomLevel()\n    node := NewNode(uint32(level), value)1\n    if uint32(level) > sl.height {\n        sl.height = uint32(level)\n    }\n    // 从 0- level层的链表均需要更新， level+1 ～ height之间的上层链表不用更新\n    for i := 0; i < level; i++ {\n        // 新节点超过height，将头节点对应层数的后继节点设置为新节点 \n        if update[i] == nil {\n            sl.header.levels[i].next = node\n            continue\n        }\n        // 修改新节点的后继节点为\n        node.levels[i].next = update[i].levels[i].next\n        // 修改每一层最后一个比value 小的节点的后继节点为新节点\n        update[i].levels[i].next = node\n    }\n    sl.length++\n    return true\n}"
    },
    {
      "id": "n6f7RnqKQFFkbFAZ6q0Bt",
      "type": "rectangle",
      "x": 809.27734375,
      "y": 116.0703125,
      "width": 740.8515625,
      "height": 1026.703125,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1567912372,
      "version": 196,
      "versionNonce": 2126622860,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659600758051,
      "link": null,
      "locked": false
    },
    {
      "id": "Ay0z1trpxJ-2cZqN4F521",
      "type": "rectangle",
      "x": 809.7734375,
      "y": 1166.93359375,
      "width": 742.34375,
      "height": 870.55859375,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 248758028,
      "version": 299,
      "versionNonce": 1401129652,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659602746485,
      "link": null,
      "locked": false
    },
    {
      "id": "R9qQQv3sPDt-woUwPaI91",
      "type": "text",
      "x": 825,
      "y": 1173.5,
      "width": 456,
      "height": 848,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 568464436,
      "version": 1063,
      "versionNonce": 598336564,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659602738135,
      "link": null,
      "locked": false,
      "text": "func (sl *SkipList) Delete(value uint32) bool {\n    var node *Node \n    last := make([]*Node, sl.height)\n    tmp := sl.header\n    for i := sl.heigth - 1; i >= 0; i-- {\n        fori tmp.levels[i].next != nil && tmp.levels[i].next.value < value {\n            tmp = tmp.levels[i].next\n        }\n        last[i] = tmp\n        if tmp.levels[i].next != nil && tmp.levels[i].next.value == value {\n            node = tmp.levels[i].next\n        }\n        if temp.levels[i].next != nil && tmp.levels[i].next.value != value {\n            return false\n        }\n    }\n    if node == nil return false\n    // lash中存放的前置节点的后继需要\n    for i := 0; i < len(node.levels); i++ {\n        last[i].levels[i].next = node.levels[i].next\n        node.levels[i].next = nil\n    }\n    // 重新修改height\n    for i := 0;  i < len(s1.header.levels); i++ {\n        if sl.header.levels[i].next == nil {\n            sl.height = uint32(i)\n            break\n        }\n    }\n    sl.length--\n    return true    \n}",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 843,
      "containerId": null,
      "originalText": "func (sl *SkipList) Delete(value uint32) bool {\n    var node *Node \n    last := make([]*Node, sl.height)\n    tmp := sl.header\n    for i := sl.heigth - 1; i >= 0; i-- {\n        fori tmp.levels[i].next != nil && tmp.levels[i].next.value < value {\n            tmp = tmp.levels[i].next\n        }\n        last[i] = tmp\n        if tmp.levels[i].next != nil && tmp.levels[i].next.value == value {\n            node = tmp.levels[i].next\n        }\n        if temp.levels[i].next != nil && tmp.levels[i].next.value != value {\n            return false\n        }\n    }\n    if node == nil return false\n    // lash中存放的前置节点的后继需要\n    for i := 0; i < len(node.levels); i++ {\n        last[i].levels[i].next = node.levels[i].next\n        node.levels[i].next = nil\n    }\n    // 重新修改height\n    for i := 0;  i < len(s1.header.levels); i++ {\n        if sl.header.levels[i].next == nil {\n            sl.height = uint32(i)\n            break\n        }\n    }\n    sl.length--\n    return true    \n}"
    },
    {
      "id": "8QckNOyWOcRWfFEKoIia1",
      "type": "rectangle",
      "x": 293.80859375,
      "y": 1181.8046875,
      "width": 492.13671874999994,
      "height": 405.5625,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 116894260,
      "version": 461,
      "versionNonce": 1279665972,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659603244568,
      "link": null,
      "locked": false
    },
    {
      "id": "nbbV4EZ2SsNnsG47S-gAL",
      "type": "text",
      "x": 319,
      "y": 1183.5,
      "width": 464,
      "height": 371,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 1251428492,
      "version": 331,
      "versionNonce": 181174540,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659601314629,
      "link": null,
      "locked": false,
      "text": "func (sl *SkipList) find(value uint32) *Node {\n    var node *Node\n    tmp := sl.header\n    for i := sl.height - 1; i >= 0; i-- {\n        fori tmp.levels[i].next != nil && tmp.levels[i].next.value <= value {\n            tmp = tmp.levels[i].next\n        }\n        if tmp.value == value {\n            node = tmp\n            break;\n        }\n    }\n    return node\n}",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 366,
      "containerId": null,
      "originalText": "func (sl *SkipList) find(value uint32) *Node {\n    var node *Node\n    tmp := sl.header\n    for i := sl.height - 1; i >= 0; i-- {\n        fori tmp.levels[i].next != nil && tmp.levels[i].next.value <= value {\n            tmp = tmp.levels[i].next\n        }\n        if tmp.value == value {\n            node = tmp\n            break;\n        }\n    }\n    return node\n}"
    },
    {
      "id": "V7kulQ8SY9rfOCDnsiceP",
      "type": "text",
      "x": 157,
      "y": 171.5,
      "width": 114,
      "height": 106,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 907870988,
      "version": 55,
      "versionNonce": 1446111884,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659603373132,
      "link": null,
      "locked": false,
      "text": "type Node struct{\n    value uint32\n    levels []*node\n}",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 101,
      "containerId": null,
      "originalText": "type Node struct{\n    value uint32\n    levels []*node\n}"
    },
    {
      "id": "YQtsyRXYtrZaYYFKXyRRb",
      "type": "rectangle",
      "x": 314.76171875,
      "y": -283.9765625,
      "width": 603.08203125,
      "height": 214.453125,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 321940364,
      "version": 44,
      "versionNonce": 2119727796,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659603617017,
      "link": null,
      "locked": false
    },
    {
      "id": "hN7k8S24YU51mKaiOqNyz",
      "type": "text",
      "x": 374,
      "y": -262.5,
      "width": 364,
      "height": 80,
      "angle": 0,
      "strokeColor": "#000000",
      "backgroundColor": "transparent",
      "fillStyle": "hachure",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "strokeSharpness": "sharp",
      "seed": 69830924,
      "version": 93,
      "versionNonce": 1849749004,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1659603667060,
      "link": null,
      "locked": false,
      "text": "skiplist 跳表\n\nredis的zset。 rocksdb的memtable。elastic search。",
      "fontSize": 20,
      "fontFamily": 1,
      "textAlign": "left",
      "verticalAlign": "top",
      "baseline": 74,
      "containerId": null,
      "originalText": "skiplist 跳表\n\nredis的zset。 rocksdb的memtable。elastic search。"
    }
  ],
  "appState": {
    "gridSize": null,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}