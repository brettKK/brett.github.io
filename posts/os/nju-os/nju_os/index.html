<!DOCTYPE html>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<html lang="zh-cn">
  <head>
    <title>brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="http://jyywiki.cn/os/2022/
02 程序与编译器 🔗在vi里编译c文件。 :!gcc %
什么是程序？ 🔗你在南京大学上过最牛的课是什么？
《程序设计语言的形式语义》 梁红瑾
gdb a.out layout src (c程序视角) layout asm （汇编视角） start
问题1: gdb Unable to find Mach task port 解决过程： mac下不能安装gdb， lldb替代。">
<meta name="generator" content="Hugo 0.103.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/zenburn.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" href="http://brettkk.github.io/css/syntax.css" />


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title"></h1>

    <div class="tip">
        <time datetime="0001-01-01 00:00:00 &#43;0000 UTC">Jan 1, 0001</time>
        <span class="split">
          ·
        </span>
        <span>
          1132 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          6 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#02-程序与编译器">02 程序与编译器</a>
      <ul>
        <li><a href="#什么是程序">什么是程序？</a></li>
        <li><a href="#什么是正确的编译">什么是正确的编译？</a></li>
        <li><a href="#操作系统的常见应用程序">操作系统的常见应用程序</a></li>
      </ul>
    </li>
    <li><a href="#03-多处理器编程">03 多处理器编程</a>
      <ul>
        <li><a href="#实现原子性">实现原子性</a></li>
        <li><a href="#理解并发程序的执行">理解并发程序的执行</a></li>
        <li><a href="#并发控制互斥">并发控制：互斥</a></li>
        <li><a href="#并发控制-线程同步">并发控制： 线程同步</a></li>
      </ul>
    </li>
    <li><a href="#虚拟化">虚拟化</a>
      <ul>
        <li><a href="#进程">进程</a></li>
        <li><a href="#c标准库的实现">C标准库的实现</a></li>
        <li><a href="#可执行文件">可执行文件</a></li>
        <li><a href="#动态链接和加载">动态链接和加载</a></li>
        <li><a href="#安装qemu">安装QEMU</a></li>
      </ul>
    </li>
    <li><a href="#持久化">持久化</a>
      <ul>
        <li><a href="#文件">文件</a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p><a href="http://jyywiki.cn/os/2022/" target="_blank" rel="noopener">http://jyywiki.cn/os/2022/</a></p>
<hr>
<h2 id="02-程序与编译器">02 程序与编译器 <a href="#02-%e7%a8%8b%e5%ba%8f%e4%b8%8e%e7%bc%96%e8%af%91%e5%99%a8" class="anchor">🔗</a></h2><p>在vi里编译c文件。 :!gcc %</p>
<h3 id="什么是程序">什么是程序？ <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%a8%8b%e5%ba%8f" class="anchor">🔗</a></h3><p>你在南京大学上过最牛的课是什么？</p>
<p>《程序设计语言的形式语义》 梁红瑾</p>
<p>gdb a.out
layout src (c程序视角)
layout asm （汇编视角）
start</p>
<p>问题1: gdb Unable to find Mach task port
解决过程： mac下不能安装gdb， lldb替代。</p>
<ul>
<li>程序是状态机。
<ul>
<li>状态等于内存+寄存器。转移函数的等于程序的一条条指令。</li>
<li>gdb单步调试非递归的汉诺塔。</li>
<li>是状态机的话一定可以有工具（gdb，lldb）观察状态和转移之后的状态。</li>
</ul>
</li>
</ul>
<p>状态机（程序）如何停下来？</p>
<p>调用syscall时，任由os修改。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_start</span>() {
</span></span><span style="display:flex;"><span><span style="color:#75715e">//写一个最小版本的hello world的C程序。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>gcc -c a.c &amp;&amp; objdump -d a.o &amp;&amp; ld a.o &amp;&amp; ./a.out</p>
<p>gdb a.out
starti
GDB 官方文档。 STFW, RTFM。The friendly Manual。</p>
<p>问题： hello world的C程序执行的第一条指令在哪里？</p>
<p>等价问： 二进制程序状态机的初始状态是什么？ main的第一条指令吗？ libc的_start函数吗？</p>
<p>问gdb吧。 lib64/ld-linux-x86-64.so.2中。</p>
<p>lib64/ld-linux-x86-64.so加载了libc。</p>
<p>谁规定了是ld-linux-x86-64.so， 而不是xxxx.so?
readelf。 一切建立在确定的机制上。</p>
<h3 id="什么是正确的编译">什么是正确的编译？ <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%a3%e7%a1%ae%e7%9a%84%e7%bc%96%e8%af%91" class="anchor">🔗</a></h3><p>正确性： 源代码的状态机 与 二进制的状态机的可观测行为严格一致。</p>
<p>compiler 保证观测一致性的前提下 改写代码。</p>
<h3 id="操作系统的常见应用程序">操作系统的常见应用程序 <a href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%b8%b8%e8%a7%81%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f" class="anchor">🔗</a></h3><p>一般的程序 = 计算 -&gt; syscall -&gt; ...</p>
<p>在一般的程序的视角下操作系统就是syscall。strace命令。</p>
<p>core utilities。</p>
<p>系统工具。 bash， binutils。</p>
<p>重要工具： gcc， binutils, gdb, strace。</p>
<hr>
<h2 id="03-多处理器编程">03 多处理器编程 <a href="#03-%e5%a4%9a%e5%a4%84%e7%90%86%e5%99%a8%e7%bc%96%e7%a8%8b" class="anchor">🔗</a></h2><p>wget <a href="http://jyywiki.cn/pages/OS/2022/demos/thread.h" target="_blank" rel="noopener">http://jyywiki.cn/pages/OS/2022/demos/thread.h</a></p>
<p>如何证明线程确实共享内存？</p>
<p>如何证明线程具有独立的栈，以及栈的范围？</p>
<p>8M的线程栈大小。</p>
<p>创建线程使用了哪些系统调用？</p>
<p>能不能在gdb中调试？</p>
<h3 id="实现原子性">实现原子性 <a href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e5%ad%90%e6%80%a7" class="anchor">🔗</a></h3><p>互斥和原子性。</p>
<p>lock(&amp;lk), unlock(&amp;lk) 可以实现临界区之间的线程串行化执行。</p>
<ul>
<li>99%的并发问题可以用一个队列解决
<ul>
<li>worker thread去锁保护的队列里取任务</li>
<li>PDC chap 1 (<a href="https://web.mit.edu/dimitrib/www/pdc.html" target="_blank" rel="noopener">https://web.mit.edu/dimitrib/www/pdc.html</a>)</li>
<li>own thinking，比如有哪些开源项目？</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> done;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">join</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>done) {
</span></span><span style="display:flex;"><span>        ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>// while (!done);
// 可能被编译器优化为
// if(!done) while(1);</p>
<p>gcc -c -o2 a.c | objdump -d a.o</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> done;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">join</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>done) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">:::</span><span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>加上volatile后，查看汇编指令，每次循环都会查询内存里的变量后。
因此产生了volatile(易变的)的编程语义， 所以每次读易变的变量时读内存，每次写易变的变量时写内存。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">volatile</span> done;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">join</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>done) {
</span></span><span style="display:flex;"><span>        ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">T1</span>() {
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;y = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, y); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">T2</span>() {
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;x = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pipe to head -n 1000000 |sort|uniq -c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以看到 x = 0 y = 0 出现了...
</span></span></span></code></pre></div><p>next， 加上volatile后保证汇编层面上的语义正确。 但是在cpu内部维护指令依赖的DAG，不依赖的指令同时发射执行。
现在的处理器也是数据流分析器，编译器，做出应有的应对，它才可以跑得快。
所以printf y 可以在写入x 之前执行。可以在mfence保证指令执行顺序与代码编写顺序一致。</p>
<p>[1]<a href="https://research.swtch.com/hwmm" target="_blank" rel="noopener">Hardware Memory Models by Russ Cox</a></p>
<h3 id="理解并发程序的执行">理解并发程序的执行 <a href="#%e7%90%86%e8%a7%a3%e5%b9%b6%e5%8f%91%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%89%a7%e8%a1%8c" class="anchor">🔗</a></h3><p>并发程序 = 多个执行流， 共享内存的状态机。</p>
<p>peterson算法。
A举旗子，往厕所门上贴“B”正在使用的标签。
B举旗子，往厕所门上贴“A”正在使用的标签。
当 对方的旗子举起来了，且门上的名字不是自己，则等待。其他情况，可以进。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">volatile</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, turn <span style="color:#f92672">=</span> A;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Ta</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        turn <span style="color:#f92672">=</span> B;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>( y <span style="color:#f92672">&amp;&amp;</span> turn <span style="color:#f92672">==</span> B) ;
</span></span><span style="display:flex;"><span>        critical_section();
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tb</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        turn <span style="color:#f92672">=</span> A;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>( x <span style="color:#f92672">&amp;&amp;</span> turn <span style="color:#f92672">=</span> A) ;
</span></span><span style="display:flex;"><span>        critical_section();
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>画状态机（pc1, pc2, x, y, turn）。用工具画。
model checker。状态机可以抽象为图。可达性。</p>
<h3 id="并发控制互斥">并发控制：互斥 <a href="#%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e4%ba%92%e6%96%a5" class="anchor">🔗</a></h3><p>实现互斥的根本困难是： 不能同时读/写内存。</p>
<p>如何在多处理器上实现线程互斥？</p>
<h4 id="自旋锁spin-lock">自旋锁(spin lock)。 <a href="#%e8%87%aa%e6%97%8b%e9%94%81spin-lock" class="anchor">🔗</a></h4><p>硬件加指令。</p>
<p>xchg指令： 先看一下，然后中途没人改动时改掉。其他的stdatomic.h</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> table <span style="color:#f92672">=</span> YES;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>() {
</span></span><span style="display:flex;"><span>retry:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> got <span style="color:#f92672">=</span> xchg(<span style="color:#f92672">&amp;</span>table, NOPE);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (got <span style="color:#f92672">==</span> NOPE) <span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>    assert(got <span style="color:#f92672">==</span> yes);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() {
</span></span><span style="display:flex;"><span>    xchg(<span style="color:#f92672">&amp;</span>table, YES);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> locked <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>( xchg(<span style="color:#f92672">&amp;</span>locked, <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() { xchg(<span style="color:#f92672">&amp;</span>locked, <span style="color:#ae81ff">0</span>); }
</span></span></code></pre></div><p>x86的lock指令的实现。 L1 cache的MESI状态协调。</p>
<p>RISC-V的另一种原子操作的设计。</p>
<p>本质是load  exec store的原子性。</p>
<p>Load-Reserved/Store-Conditional (LR/SC)</p>
<p>使用场景： 短临界区，少竞争下，防止线程被切换（程序自身做不到，OS控制持锁时OS禁止中断和抢占）。
操作系统内核的并发数据结构使用spin lock。</p>
<p>缺陷： 空转。 获得自旋锁的线程被os切换出去了（OS也很难保证，虚拟机不能关中断）。</p>
<h4 id="互斥锁mutex-lock">互斥锁（mutex lock）。 <a href="#%e4%ba%92%e6%96%a5%e9%94%81mutex-lock" class="anchor">🔗</a></h4><p>天黑请闭眼，停止操作。</p>
<p>长临界区的互斥。写文件。把锁的实现放到操作系统里。通过系统调用访问locked。</p>
<ul>
<li>自旋锁
<ul>
<li>fast path。 xchg 成功，进入</li>
<li>slow path。 xchg 失败失败，自旋等待</li>
</ul>
</li>
<li>互斥锁，通过系统调用访问locked
<ul>
<li>slow path。更快。上锁失败的线程不再占用cpu</li>
<li>fast path。上锁成功也需要syscall到内核态</li>
</ul>
</li>
</ul>
<h4 id="futexfast-userspace-mutexes">futex（Fast Userspace muTexes） <a href="#futexfast-userspace-mutexes" class="anchor">🔗</a></h4><p>借鉴 自旋锁和互斥锁的优点。
设计futex的人第一次也没有写对。</p>
<ul>
<li>fast path。 一条原子指令，上锁成功后立即返回。</li>
<li>slow path。 上锁失败，执行系统调用睡眠。</li>
</ul>
<h3 id="并发控制-线程同步">并发控制： 线程同步 <a href="#%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6-%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5" class="anchor">🔗</a></h3><p>互斥是竞争。 同步是协作。</p>
<p>同步问题： 生产者-消费者； 哲学家吃饭。
同步的实现方法： 条件变量, 信号量。</p>
<p>生产者-消费者问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tproduce</span>() { <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) printf(<span style="color:#e6db74">&#34;(&#34;</span>);}
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tconsumer</span>() { <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) printf(<span style="color:#e6db74">&#34;)&#34;</span>);}
</span></span></code></pre></div><p>同步： 1 等到有空位时才能打印左括号。2 等到能配对时才能打印右括号。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;thread.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;thread-sync.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>mutex_t lk <span style="color:#f92672">=</span> MUTEX_INIT();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tproduce</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    retry:
</span></span><span style="display:flex;"><span>        mutex_lock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> n)  {
</span></span><span style="display:flex;"><span>            mutex_unlock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;(&#34;</span>);
</span></span><span style="display:flex;"><span>        mutex_unlock(<span style="color:#f92672">&amp;</span>lk);   
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tconsumer</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    retry:
</span></span><span style="display:flex;"><span>        mutex_lock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            mutex_unlock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;)&#34;</span>);
</span></span><span style="display:flex;"><span>        mutex_unlock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不管缓冲区空还是满，每个线程都会拿来加锁。</p>
<p>条件变量：万能同步的方法。</p>
<ul>
<li>条件变量API：
<ul>
<li>wait(cv, mutex) 调用时必须已经获得mutex，则释放mutex，进入睡眠;</li>
<li>signal(cv) 唤醒等待cv的线程。</li>
<li>broadcast/notifyAll(cv) 唤醒All。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tproduce</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        mutex_lock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>count <span style="color:#f92672">!=</span>n ) {
</span></span><span style="display:flex;"><span>            mutex_unlock_and_sleep(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// mutex_lock(&amp;lk);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;(&#34;</span>);
</span></span><span style="display:flex;"><span>        wakeup();
</span></span><span style="display:flex;"><span>        mutex_unlock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tconsumer</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        mutex_lock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            mutex_unlock_and_sleep(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;)&#34;</span>);
</span></span><span style="display:flex;"><span>        wakeup();
</span></span><span style="display:flex;"><span>        mutex_unlock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// has bug in it. model checker.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// producer 唤醒 producer， 或者consumer 唤醒 consumer时，代码有问题了...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>mutex_t lk <span style="color:#f92672">=</span> MUTEX_INIT();
</span></span><span style="display:flex;"><span>cond_t cv <span style="color:#f92672">=</span> COND_INIT();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tproduce</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        mutex_lock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> n) { <span style="color:#75715e">// 改while
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cond_wait(<span style="color:#f92672">&amp;</span>cv, <span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;(&#34;</span>); count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        cond_signal(<span style="color:#f92672">&amp;</span>cv); <span style="color:#75715e">//改broadcast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        mutex_unlock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tconsumer</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        mutex_lock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">// 改while
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cond_wait(<span style="color:#f92672">&amp;</span>cv, <span style="color:#f92672">&amp;</span>lk); <span style="color:#75715e">//被唤醒时持有mutex lock。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;)&#34;</span>); count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        cond_signal(<span style="color:#f92672">&amp;</span>cv);
</span></span><span style="display:flex;"><span>        mutex_unlock(<span style="color:#f92672">&amp;</span>lk);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要2个条件变量，保证producer只唤醒consumer， consumer只唤醒producer。</p>
<p>条件变量： 实现并行计算。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> job {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>run)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>args);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>args;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> job <span style="color:#f92672">*</span>job;
</span></span><span style="display:flex;"><span>    mutex_lock(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">!</span>(job<span style="color:#f92672">=</span>get_job()) ){
</span></span><span style="display:flex;"><span>        wait(<span style="color:#f92672">&amp;</span>cv, <span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>    job<span style="color:#f92672">-&gt;</span>run(job<span style="color:#f92672">-&gt;</span>arg);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>DAG，拓扑排序，按层容易并行化计算。</p>
<p>条件变量： 实现线程间的交替打印。</p>
<p>三个线程，总是打印&lt;&gt;&lt;<em>,  &gt;&lt;&gt;</em>。 fish.c</p>
<p>信号量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">producer</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        P(<span style="color:#f92672">&amp;</span>empty); <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;(&#34;</span>);
</span></span><span style="display:flex;"><span>        V(<span style="color:#f92672">&amp;</span>fill);  <span style="color:#75715e">// fill++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">consumer</span>() {
</span></span><span style="display:flex;"><span>    P(<span style="color:#f92672">&amp;</span>fill);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;)&#34;</span>);
</span></span><span style="display:flex;"><span>    V(<span style="color:#f92672">&amp;</span>empty); <span style="color:#75715e">// empty--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>哲学家吃饭问题。（1960 Djstra）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>mutex_lock(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> ( <span style="color:#f92672">!</span>(avail[lhs] <span style="color:#f92672">&amp;&amp;</span> avail[rhs]) ) {
</span></span><span style="display:flex;"><span>    wait(<span style="color:#f92672">&amp;</span>cv, <span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>avail[lhs] <span style="color:#f92672">=</span> avail[rhs] <span style="color:#f92672">=</span> false; <span style="color:#75715e">// 在锁的保护下拿起 左右的叉子。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 吃饭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mutex_lock(<span style="color:#f92672">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>avail[lhs]<span style="color:#f92672">=</span>avail[rhs]<span style="color:#f92672">=</span>true; <span style="color:#75715e">// 还回去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>broadcast(<span style="color:#f92672">&amp;</span>cv);
</span></span><span style="display:flex;"><span>mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);
</span></span></code></pre></div><p>也可以不用信号量， 让一个人集中管理。 分布式系统中常见。</p>
<p>共享内存是万恶之源。<br>
do not communicate by sharing memmory, instead share memory by communicating。 -- effective go <br>
既然生产者消费者能解决大部分问题的时候，提供API就行了。例如golang的channel， rust的channel。</p>
<p>软件是需求（规约）在计算机数字世界里的投影。</p>
<p>应对bug的方法。 防御性编程。</p>
<p>举例：平衡二叉树的旋转。
把每个节点&lt;x, y, a, b, c&gt;的assert &lt;left, right, parent&gt;写出来，写出规约，就完全知道代码该怎么写了。
在写代码时写出assert，不仅写完了代码，而且解释代码为什么是对的，会加分。</p>
<p>spinlock-xv6.c 中各种防御性编程。</p>
<p>动态程序分析 sanitizer。</p>
<h2 id="虚拟化">虚拟化 <a href="#%e8%99%9a%e6%8b%9f%e5%8c%96" class="anchor">🔗</a></h2><h3 id="进程">进程 <a href="#%e8%bf%9b%e7%a8%8b" class="anchor">🔗</a></h3><p>pstree</p>
<p>loader把os加载进来，执行kernel _start()代码，执行第一个程序/bin/init init进程, 中断/异常处理程序。<br>
后续其他进程都是init进程的子进程。</p>
<p>创建进程的system call api。 fork, execve, exit 状态机的创建和退出。</p>
<p>fork() 叉子。状态机的复制。</p>
<pre tabindex="0"><code>fork的应用 （文件描述符的复制，写时复制）

int open(const char *pathname, int flags) 
多进程（线程）write时os管理了文件的偏移量。flags = O_CLOEXEC时子进程不复制文件描述符。

dup() 的两个文件描述是共享offset，还是独立offset？读RTFM manual。共享offset。

写时复制copy on write
    页面是os管理的,被修改的页面才会复制
</code></pre><p>execve 重置一个进程的状态机，另外一个程序的初始化状态机。</p>
<ul>
<li>三大类系统调用
<ul>
<li>进程的syscall，fork，execve,exit。</li>
<li>内存的syscall， mmap虚拟地址空间管理。</li>
<li>文件的syscall, open， close, read, write, mkdir, link, unlink</li>
<li>其他，网络等等。</li>
</ul>
</li>
</ul>
<h4 id="进程的地址空间">进程的地址空间 <a href="#%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" class="anchor">🔗</a></h4><pre><code>SIGSEG。 address boundary errror.

strace pmap pid &amp; | vim -

os提供查看进程地址空间的机制。man 5 proc
/proc/pid/maps     

VSDO。 只读系统调用不陷入内核态。time的实现。vvar， vdso。
系统调用只是一组api接口的约定， 不一定一定执行int指令。

mmap。

地址空间的隔离。
</code></pre>
<h4 id="系统调用shell">系统调用，shell <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8shell" class="anchor">🔗</a></h4><p>sh-xv6.c 零依赖的shell实现。</p>
<pre tabindex="0"><code>ubuntu@careful-clingfish:~/linux-5.19/include/linux$ strace ulimit
strace: Can&#39;t stat &#39;ulimit&#39;: No such file or directory

$ strace bash -c &#34;ulimit -c&#34;
</code></pre><p>strace -f -o /tmp/strace.log ./sh
tail -f /tmp/strace.log</p>
<p>job control.
jobs, fg, bg, &amp;.</p>
<p>ctrl + z 把vi放到后台运行。</p>
<p>为什么ctrl + c 可以退出程式。
为什么有些程序不会退出？ SIGINT, SIGQUIT。 终端发出信号给前台进程，程序是否注册信息处理函数来决定是否退出。</p>
<p>session， process group和信号。SID， PGID。 nohup。
man setpgid。</p>
<p>为什么tmux可以管理多个窗口？
strace -f -o /tmp/strace.log tmux
终端。 os中一类特殊的设备。 tty， stty...
不同的窗口是不同的终端设备。</p>
<hr>
<h3 id="c标准库的实现">C标准库的实现 <a href="#c%e6%a0%87%e5%87%86%e5%ba%93%e7%9a%84%e5%ae%9e%e7%8e%b0" class="anchor">🔗</a></h3><p>在系统调用之上构建方便程序使用的C标准库。</p>
<p>C语言是什么？ 包含什么？</p>
<p>C标准库的设计与实现。</p>
<p>基于libc的应用程序。</p>
<ul>
<li>stddef.h    size_t</li>
<li>stdint.h    int32_t, uint64</li>
<li>stdbool.h   bool, true, false</li>
<li>float.h, limits.h</li>
<li>stdarg.h    syscall, syscall0, syscall1</li>
<li>inttypes.h</li>
</ul>
<center><strong>封装系统调用。</strong></center>
<pre><code>execve--封装为好用--&gt;execlp。

memset 多线程访问。标准库只对“标准库内部数据”的线程安全性负责。
</code></pre>
<center><strong>封装纯粹的计算。</strong></center>
<p>排序和查找。
低配置。qsort， bsearch。
高配置。c++ sort。</p>
<center><strong>封装os里的对象。 文件描述符。</strong></center>
<p>FILE * 背后是封装了一个文件描述符。</p>
<p>extern char **environ; 在哪里定义，谁赋值的。</p>
<center><strong>封装地址空间</strong></center>
<p>内存空间的管理。    malloc, free。区间管理问题。</p>
<p>线段树，区间树，红黑树？ best，worst的时间复杂度都是logn。</p>
<ul>
<li>
<p>越小的对象分配越频繁</p>
</li>
<li>
<p>较为频繁地分配中等大小的对象</p>
</li>
<li>
<p>低频率的分配大对象</p>
</li>
<li>
<p>设计两套系统（人类也是如此，直觉反馈，理想思考）</p>
<ul>
<li>fast path 性能好，覆盖大部分情况
<ul>
<li>per cpu, per thread 无锁能独立分配内存。</li>
</ul>
</li>
<li>slow path
<ul>
<li>加锁去全局的池子里分配。</li>
</ul>
</li>
</ul>
</li>
</ul>
<center><strong> 无限的封装 </strong></center>
<ul>
<li>The GNU C Library</li>
<li>Newlib</li>
<li>C++ 编译器</li>
<li>CPython</li>
<li>Go 最开始的编译器是C写的。</li>
</ul>
<h3 id="可执行文件">可执行文件 <a href="#%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6" class="anchor">🔗</a></h3><p>可执行文件，描述了状态机的初始状态 + 迁移的数据结构。</p>
<ul>
<li>状态
<ul>
<li>寄存器， ABI规定</li>
<li>内存（地址空间）
<ul>
<li>二进制文件 + ABI决定</li>
</ul>
</li>
<li>其他信息， 调试，core dump信息。 DWARF Debug Format。</li>
</ul>
</li>
</ul>
<p>可执行ELF（/usr/include/elf.h）： 具有可执行权限，能被execve识别。系统调用execve决定是否可以执行。</p>
<p>she-bang。 #！可执行文件。</p>
<p>gnu binutils 生成和分析可执行文件。</p>
<p>可执行文件的运行时状态，gdb查看。</p>
<p>调试信息，stack unwinding。</p>
<p>静态链接中的重定位。call func的next pc + offset。
静态ELF加载器。
源码，编译为汇编文件（指令）。
汇编为目标文件（一一对应翻译为二进制代码.o）。
链接为可执行文件(多个.o变为a.out)。</p>
<h3 id="动态链接和加载">动态链接和加载 <a href="#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%92%8c%e5%8a%a0%e8%bd%bd" class="anchor">🔗</a></h3><pre tabindex="0"><code>DL_HEAD
load(libc.dl)   # 加载动态库
import(putchar) # 加载外部符号
export(hello)   # 导出符号

DL_CODE
hello:
    call DSYM(putchar) # 动态链接符号
</code></pre><p>DSYM是间接访问内存。 有两种情况： 来自其他编译单元（可以静态链接，直接pc相对跳转）；访问动态链接库（编译时不能决定地址）。</p>
<p>GOT   PLT。</p>
<p>动态链接。</p>
<p>加载。</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TB
    Start(开始) --&gt; Open[打开冰箱门]
    Open --&gt; Put[把大象放进去]
    Put[把大象放进去] --&gt; IsFit{&#34;冰箱小不小？&#34;}
    
    IsFit --&gt;|不小| Close[把冰箱门关上]
    Close --&gt; End(结束)
        
    IsFit --&gt;|小| Change[换个大冰箱]
    Change --&gt; Open
</code></pre>


<div class="goat svg-container ">
  
    <svg
      xmlns="http://www.w3.org/2000/svg"
      font-family="Menlo,Lucida Console,monospace"
      
        viewBox="0 0 680 121"
      >
      <g transform='translate(8,16)'>
<path d='M 440,0 L 464,0' fill='none' stroke='currentColor'></path>
<path d='M 576,0 L 584,0' fill='none' stroke='currentColor'></path>
<path d='M 408,16 L 440,16' fill='none' stroke='currentColor'></path>
<path d='M 552,16 L 560,16' fill='none' stroke='currentColor'></path>
<path d='M 144,32 L 176,32' fill='none' stroke='currentColor'></path>
<path d='M 176,32 L 208,32' fill='none' stroke='currentColor'></path>
<path d='M 296,32 L 312,32' fill='none' stroke='currentColor'></path>
<path d='M 312,32 L 328,32' fill='none' stroke='currentColor'></path>
<path d='M 440,32 L 464,32' fill='none' stroke='currentColor'></path>
<path d='M 576,32 L 584,32' fill='none' stroke='currentColor'></path>
<path d='M 384,48 L 408,48' fill='none' stroke='currentColor'></path>
<path d='M 512,48 L 536,48' fill='none' stroke='currentColor'></path>
<path d='M 128,64 L 144,64' fill='none' stroke='currentColor'></path>
<path d='M 144,64 L 160,64' fill='none' stroke='currentColor'></path>
<path d='M 192,64 L 208,64' fill='none' stroke='currentColor'></path>
<path d='M 208,64 L 224,64' fill='none' stroke='currentColor'></path>
<path d='M 440,64 L 464,64' fill='none' stroke='currentColor'></path>
<path d='M 576,64 L 584,64' fill='none' stroke='currentColor'></path>
<path d='M 408,80 L 440,80' fill='none' stroke='currentColor'></path>
<path d='M 552,80 L 560,80' fill='none' stroke='currentColor'></path>
<path d='M 440,96 L 464,96' fill='none' stroke='currentColor'></path>
<path d='M 576,96 L 584,96' fill='none' stroke='currentColor'></path>
<path d='M 128,64 L 128,80' fill='none' stroke='currentColor'></path>
<path d='M 144,32 L 144,64' fill='none' stroke='currentColor'></path>
<path d='M 160,64 L 160,80' fill='none' stroke='currentColor'></path>
<path d='M 176,0 L 176,32' fill='none' stroke='currentColor'></path>
<path d='M 192,64 L 192,80' fill='none' stroke='currentColor'></path>
<path d='M 208,32 L 208,64' fill='none' stroke='currentColor'></path>
<path d='M 224,64 L 224,80' fill='none' stroke='currentColor'></path>
<path d='M 280,48 L 280,64' fill='none' stroke='currentColor'></path>
<path d='M 312,0 L 312,32' fill='none' stroke='currentColor'></path>
<path d='M 344,48 L 344,64' fill='none' stroke='currentColor'></path>
<path d='M 408,16 L 408,48' fill='none' stroke='currentColor'></path>
<path d='M 408,48 L 408,80' fill='none' stroke='currentColor'></path>
<path d='M 440,0 L 440,16' fill='none' stroke='currentColor'></path>
<path d='M 440,16 L 440,32' fill='none' stroke='currentColor'></path>
<path d='M 440,64 L 440,80' fill='none' stroke='currentColor'></path>
<path d='M 440,80 L 440,96' fill='none' stroke='currentColor'></path>
<path d='M 536,32 L 536,48' fill='none' stroke='currentColor'></path>
<path d='M 536,48 L 536,64' fill='none' stroke='currentColor'></path>
<path d='M 8,80 L 24,48' fill='none' stroke='currentColor'></path>
<path d='M 24,48 L 48,0' fill='none' stroke='currentColor'></path>
<path d='M 56,80 L 72,48' fill='none' stroke='currentColor'></path>
<path d='M 624,48 L 640,16' fill='none' stroke='currentColor'></path>
<path d='M 640,16 L 648,0' fill='none' stroke='currentColor'></path>
<path d='M 640,80 L 648,64' fill='none' stroke='currentColor'></path>
<path d='M 24,48 L 40,80' fill='none' stroke='currentColor'></path>
<path d='M 48,0 L 72,48' fill='none' stroke='currentColor'></path>
<path d='M 72,48 L 88,80' fill='none' stroke='currentColor'></path>
<path d='M 624,48 L 640,80' fill='none' stroke='currentColor'></path>
<path d='M 640,80 L 648,96' fill='none' stroke='currentColor'></path>
<path d='M 640,16 L 648,32' fill='none' stroke='currentColor'></path>
<path d='M 576,0 A 16,16 0 0,0 560,16' fill='none' stroke='currentColor'></path>
<path d='M 552,16 A 16,16 0 0,0 536,32' fill='none' stroke='currentColor'></path>
<path d='M 296,32 A 16,16 0 0,0 280,48' fill='none' stroke='currentColor'></path>
<path d='M 328,32 A 16,16 0 0,1 344,48' fill='none' stroke='currentColor'></path>
<path d='M 560,16 A 16,16 0 0,0 576,32' fill='none' stroke='currentColor'></path>
<path d='M 280,64 A 16,16 0 0,0 264,80' fill='none' stroke='currentColor'></path>
<path d='M 280,64 A 16,16 0 0,1 296,80' fill='none' stroke='currentColor'></path>
<path d='M 344,64 A 16,16 0 0,0 328,80' fill='none' stroke='currentColor'></path>
<path d='M 344,64 A 16,16 0 0,1 360,80' fill='none' stroke='currentColor'></path>
<path d='M 576,64 A 16,16 0 0,0 560,80' fill='none' stroke='currentColor'></path>
<path d='M 536,64 A 16,16 0 0,0 552,80' fill='none' stroke='currentColor'></path>
<path d='M 560,80 A 16,16 0 0,0 576,96' fill='none' stroke='currentColor'></path>
<text text-anchor='middle' x='8' y='100' fill='currentColor' style='font-size:1em'>1</text>
<text text-anchor='middle' x='40' y='100' fill='currentColor' style='font-size:1em'>2</text>
<text text-anchor='middle' x='56' y='100' fill='currentColor' style='font-size:1em'>3</text>
<text text-anchor='middle' x='88' y='100' fill='currentColor' style='font-size:1em'>4</text>
<text text-anchor='middle' x='128' y='100' fill='currentColor' style='font-size:1em'>1</text>
<text text-anchor='middle' x='160' y='100' fill='currentColor' style='font-size:1em'>2</text>
<text text-anchor='middle' x='192' y='100' fill='currentColor' style='font-size:1em'>3</text>
<text text-anchor='middle' x='224' y='100' fill='currentColor' style='font-size:1em'>4</text>
<text text-anchor='middle' x='264' y='100' fill='currentColor' style='font-size:1em'>1</text>
<text text-anchor='middle' x='296' y='100' fill='currentColor' style='font-size:1em'>2</text>
<text text-anchor='middle' x='328' y='100' fill='currentColor' style='font-size:1em'>3</text>
<text text-anchor='middle' x='360' y='100' fill='currentColor' style='font-size:1em'>4</text>
<text text-anchor='middle' x='480' y='4' fill='currentColor' style='font-size:1em'>1</text>
<text text-anchor='middle' x='480' y='36' fill='currentColor' style='font-size:1em'>2</text>
<text text-anchor='middle' x='480' y='68' fill='currentColor' style='font-size:1em'>3</text>
<text text-anchor='middle' x='480' y='100' fill='currentColor' style='font-size:1em'>4</text>
<text text-anchor='middle' x='600' y='4' fill='currentColor' style='font-size:1em'>1</text>
<text text-anchor='middle' x='600' y='36' fill='currentColor' style='font-size:1em'>2</text>
<text text-anchor='middle' x='600' y='68' fill='currentColor' style='font-size:1em'>3</text>
<text text-anchor='middle' x='600' y='100' fill='currentColor' style='font-size:1em'>4</text>
<text text-anchor='middle' x='664' y='4' fill='currentColor' style='font-size:1em'>1</text>
<text text-anchor='middle' x='664' y='36' fill='currentColor' style='font-size:1em'>2</text>
<text text-anchor='middle' x='664' y='68' fill='currentColor' style='font-size:1em'>3</text>
<text text-anchor='middle' x='664' y='100' fill='currentColor' style='font-size:1em'>4</text>
</g>

    </svg>
  
</div>
<h3 id="安装qemu">安装QEMU <a href="#%e5%ae%89%e8%a3%85qemu" class="anchor">🔗</a></h3><pre tabindex="0"><code>$./configure
Using &#39;./build&#39; as the directory for build output

ERROR: Cannot find Ninja 
</code></pre><p>echo 'eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;' &gt;&gt; ~/.zprofile <br>
brew install ninja<br></p>
<p>[]<a href="https://macappstore.org/ninja/" target="_blank" rel="noopener"> Install ninja on Mac OSX</a></p>
<pre tabindex="0"><code>Using &#39;./build&#39; as the directory for build output
Disabling PIE due to missing toolchain support

ERROR: pkg-config binary &#39;pkg-config&#39; not found
</code></pre><p>brew install pkg-config</p>
<h2 id="持久化">持久化 <a href="#%e6%8c%81%e4%b9%85%e5%8c%96" class="anchor">🔗</a></h2><h3 id="文件">文件 <a href="#%e6%96%87%e4%bb%b6" class="anchor">🔗</a></h3>
    </div>

    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <script src="https://utteranc.es/client.js"
repo="brettKK/brettkk.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>  

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-cactus-plus'>nodejh</a>
      </div>
    
</footer>




  </body>
</html>
