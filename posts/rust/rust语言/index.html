<!DOCTYPE html>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<html lang="zh-cn">
  <head>
    <title>rust语言 | brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="google comprehensive-rust 4days 🔗较短时间4 days入门。 摘要: standard library Option, Result, error handling String Vec HashMap, config hash">
<meta name="generator" content="Hugo 0.103.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/zenburn.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" href="http://brettkk.github.io/css/syntax.css" />


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">rust语言</h1>

    <div class="tip">
        <time datetime="2022-11-05 11:33:56 &#43;0800 CST">Nov 5, 2022</time>
        <span class="split">
          ·
        </span>
        <span>
          11066 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          23 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#google-comprehensive-rust-4days">google comprehensive-rust 4days</a></li>
    <li><a href="#the-rust-programming-language">《The Rust Programming Language》</a>
      <ul>
        <li><a href="#1-开始开发环境文档">1 开始(开发环境，文档)</a></li>
        <li><a href="#cargo">cargo</a></li>
        <li><a href="#2-project动手猜数小游戏">2 project：动手猜数小游戏。</a></li>
        <li><a href="#3-和其他语言类似的概念">3 和其他语言类似的概念</a></li>
        <li><a href="#4-所有权ownership">4 所有权ownership</a></li>
        <li><a href="#5结构体struct">5结构体struct</a></li>
        <li><a href="#6枚举体enum-和-模式匹配">6枚举体enum 和 模式匹配</a></li>
        <li><a href="#7-project-packagecrate-module">7 Project, package,crate, module</a></li>
        <li><a href="#8-常见的集合">8 常见的集合</a>
          <ul>
            <li><a href="#vect">Vec<T></a></li>
            <li><a href="#utf-8-encoding-in-string">UTF-8 encoding in String</a></li>
            <li><a href="#hashmapk-v">HashMap&lt;K, V&gt;</a></li>
            <li><a href="#其他数据集合">其他数据集合</a></li>
          </ul>
        </li>
        <li><a href="#9-错误处理">9 错误处理</a>
          <ul>
            <li><a href="#unrecoverable-errors-panic">unrecoverable errors panic!</a></li>
            <li><a href="#recoverable-errors-resultt-e">recoverable errors Result&lt;T, E&gt;</a></li>
          </ul>
        </li>
        <li><a href="#10-泛型trait生命周期">10 泛型，trait，生命周期</a>
          <ul>
            <li><a href="#泛泛的数据类型">泛泛的数据类型</a></li>
            <li><a href="#trait-定义通用共享的行为">trait 定义通用、共享的行为</a></li>
            <li><a href="#检查引用借用有效性--生命周期">检查引用(借用)有效性--生命周期</a></li>
          </ul>
        </li>
        <li><a href="#11-测试">11 测试</a></li>
        <li><a href="#12-project-io-code">12 project: io code</a></li>
        <li><a href="#13-函数编程语言的特点-iterator-closure">13 函数编程语言的特点： Iterator, closure</a>
          <ul>
            <li><a href="#闭包">闭包</a></li>
            <li><a href="#迭代器">迭代器</a></li>
          </ul>
        </li>
        <li><a href="#14-cargo--cratesio">14 cargo &amp; crates.io</a>
          <ul>
            <li><a href="#cargotoml">Cargo.toml</a></li>
            <li><a href="#发布到cratesio">发布到crates.io</a></li>
            <li><a href="#workspace组织项目">workspace组织项目</a></li>
            <li><a href="#从cratesio上安装软件">从crates.io上安装软件</a></li>
            <li><a href="#扩展cargo的子命令">扩展cargo的子命令</a></li>
          </ul>
        </li>
        <li><a href="#15-智能指针">15 智能指针</a></li>
        <li><a href="#16-并发">16 并发</a>
          <ul>
            <li><a href="#创建线程">创建线程</a></li>
            <li><a href="#线程间的通信message-passing-concurrencyvia-channel">线程间的通信，message-passing concurrency,via channel</a></li>
            <li><a href="#线程间共享内存共享状态-shared-state-concurrency">线程间共享内存（共享状态）， shared-state concurrency</a></li>
            <li><a href="#sync-send-trait">Sync, Send trait</a></li>
          </ul>
        </li>
        <li><a href="#17-rust在面向对象编程上的特点">17 rust在面向对象编程上的特点</a></li>
        <li><a href="#18-模式和匹配-patterns-and-matching">18 模式和匹配 patterns and matching</a></li>
        <li><a href="#19-advance-features">19 advance features</a>
          <ul>
            <li><a href="#unsafe-rust">unsafe rust</a></li>
            <li><a href="#advance-trait">advance trait</a></li>
            <li><a href="#advance-type">advance type</a></li>
            <li><a href="#macros">Macros</a></li>
          </ul>
        </li>
        <li><a href="#20-project-web-server">20 project: web server</a></li>
        <li><a href="#其他附录">其他附录</a>
          <ul>
            <li><a href="#源码结构">源码结构</a></li>
          </ul>
        </li>
        <li><a href="#项目组织">项目组织</a>
          <ul>
            <li><a href="#引入第三方依赖crate">引入第三方依赖crate</a></li>
            <li><a href="#module">module</a></li>
            <li><a href="#工作空间-rust-workspace">工作空间 rust workspace</a></li>
          </ul>
        </li>
        <li><a href="#数据">数据</a>
          <ul>
            <li><a href="#堆和栈">堆和栈</a></li>
            <li><a href="#错误处理">错误处理</a></li>
            <li><a href="#迭代器-1">迭代器</a></li>
          </ul>
        </li>
        <li><a href="#代码">代码</a>
          <ul>
            <li><a href="#函数与闭包">函数与闭包</a></li>
            <li><a href="#接口与虚表">接口与虚表</a></li>
            <li><a href="#宏">宏</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#expression--statement">expression 🆚 statement</a>
      <ul>
        <li>
          <ul>
            <li><a href="#智能指针">智能指针</a></li>
            <li><a href="#动态分派静态分派">动态分派，静态分派</a></li>
            <li><a href="#closure">closure</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#格式化输出">格式化输出</a></li>
    <li><a href="#rust书写的习惯">rust书写的习惯</a>
      <ul>
        <li><a href="#参考与资料">参考与资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <h1 id="google-comprehensive-rust-4days">google comprehensive-rust 4days <a href="#google-comprehensive-rust-4days" class="anchor">🔗</a></h1><p><strong>较短时间4 days入门。</strong><br>
摘要:
standard library <br></p>
<ul>
<li>Option, Result, error handling</li>
<li>String</li>
<li>Vec</li>
<li>HashMap, config hash algorithm</li>
<li>Box: an owned pointer for heap-alloc data</li>
<li>Rc: a shared reference counted pointer for heap-alloc data</li>
</ul>
<p>重要的traits<br>
Iterator , IntoIterator(for in)
From<T> Into<T> convert type, Drop.</p>
<p>shared state 共享内存的状态<br></p>
<ul>
<li>Arc<T>: share read-only access via <code>clone()</code></li>
<li>Mutex<T>: allow mutable access to T behind a read-only interfz</li>
<li><code>Arc&lt;Mutex&lt;Vec&lt;i32&gt;&gt;&gt;</code></li>
</ul>
<p>Send &amp; Sync <br></p>
<ul>
<li>T: send, T can move to thread. T alloc at t1 and de-alloc at t2</li>
<li>T: Sync, &amp;T can move to thread.  only if &amp;T: Send.</li>
<li>Send + Sync
<ul>
<li>大部分类型都是 i32, char, &amp;str, String, Arc<T>, Mutex<T> AtomicBool</li>
</ul>
</li>
<li>Send + !Sync
<ul>
<li>interior mutability</li>
<li>mpsc::Sender<T>, mpsc::Receiver<T></li>
<li>Cell<T> RefCell<T></li>
</ul>
</li>
<li>!Send + Sync
<ul>
<li>MutexGuard<T>,  alloc at t1 and should de-alloc at t2</li>
</ul>
</li>
<li>!Send + !Sync
<ul>
<li>Rc<T></li>
<li>*const T, *mut T</li>
</ul>
</li>
</ul>
<h1 id="the-rust-programming-language">《The Rust Programming Language》 <a href="#the-rust-programming-language" class="anchor">🔗</a></h1><p>比较全面，看完需要较长时间</p>
<h2 id="1-开始开发环境文档">1 开始(开发环境，文档) <a href="#1-%e5%bc%80%e5%a7%8b%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e6%96%87%e6%a1%a3" class="anchor">🔗</a></h2><ul>
<li>rustup.rs安装rustc， cargo， rustfmt, etc...</li>
<li>rustup update 更新rustc版本， rustc --version</li>
<li>rustup doc // offline book</li>
<li>rustup docs --book 会打开file:///Users/brett/.rustup/toolchains/nightly-aarch64-apple-darwin/share/doc/rust/html/book/index.html <br></li>
<li>IDE support via <code>rust-analyzer</code></li>
<li>docs.rs 可以看std库的api</li>
<li>cargo --version， cargo check（make sure it compiles and not gen exefile）</li>
</ul>
<p>看书时的小彩蛋， 3种螃蟹🦀️图标具有特殊含义（不能编译，运行时panic，不是预期行为）。</p>
<h2 id="cargo">cargo <a href="#cargo" class="anchor">🔗</a></h2><p><code>cargo home</code>: 在$HOME/.cargo/中存储项目的依赖。 其中，/bin：cargo install安装的程序。 /git： 对github仓库的依赖。 /registry： 对crate.io仓库的依赖。</p>
<p><code>Cargo.toml</code>清单的格式。<code>[workspace]</code>: 集成多个package一起共享相同的Cargo.lock，相同的output。<code>[profiles]</code>: 更改编译器的参数, overflow-checks, lto (link time optimizations), incremental增量编译。</p>
<h2 id="2-project动手猜数小游戏">2 project：动手猜数小游戏。 <a href="#2-project%e5%8a%a8%e6%89%8b%e7%8c%9c%e6%95%b0%e5%b0%8f%e6%b8%b8%e6%88%8f" class="anchor">🔗</a></h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> rand::Rng;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cmp::Ordering;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::io;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> secret_number <span style="color:#f92672">=</span> rand::thread_rng().gen_range(<span style="color:#ae81ff">1</span><span style="color:#f92672">..=</span><span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Please input your guess.&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> guess <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>        io::stdin()
</span></span><span style="display:flex;"><span>            .read_line(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> guess)
</span></span><span style="display:flex;"><span>            .expect(<span style="color:#e6db74">&#34;Failed to read line&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> guess: <span style="color:#66d9ef">u32</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> guess.trim().parse() {
</span></span><span style="display:flex;"><span>            Ok(num) <span style="color:#f92672">=&gt;</span> num,
</span></span><span style="display:flex;"><span>            Err(_) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">continue</span>,
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;You guessed: {guess}&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> guess.cmp(<span style="color:#f92672">&amp;</span>secret_number) {
</span></span><span style="display:flex;"><span>            Ordering::Less <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Too small!&#34;</span>),
</span></span><span style="display:flex;"><span>            Ordering::Greater <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;Too big!&#34;</span>),
</span></span><span style="display:flex;"><span>            Ordering::Equal <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                println!(<span style="color:#e6db74">&#34;You win!&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/stable/std/string/struct.String.html" target="_blank" rel="noopener">String是标准库中定义的类型</a><br>
String::new()表示new是String类型上实现的关联函数（associated function）。<br>
注意点： <a href="https://doc.rust-lang.org/stable/std/prelude/index.html" target="_blank" rel="noopener">自动导入标准库中的包</a><br>
io::stdin() 返回<a href="https://doc.rust-lang.org/stable/std/io/struct.Stdin.html" target="_blank" rel="noopener">std::io::Stdin结构体</a>。 read_line返回enum Result结构体，需要处理潜在的错误，可以使用<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.expect" target="_blank" rel="noopener">expect</a>。如果Result&lt;T, E&gt;类型的值是Ok成功，返回T。如果失败，程序在此处panic崩溃。<br></p>
<p><a href="https://crates.io/crates/rand" target="_blank" rel="noopener">rand</a>提供生成随机数的功能<br>
use rand::Rng; 为什么需要导入Rng? <br>
gen_range()方法在trait Rng中定义。如果要使用trait中的方法，trait必须导入到scope中。<br></p>
<p>如果不知道依赖的crate该怎么使用？<strong><font color=blue>cargo doc --open</font></strong></p>
<h2 id="3-和其他语言类似的概念">3 和其他语言类似的概念 <a href="#3-%e5%92%8c%e5%85%b6%e4%bb%96%e8%af%ad%e8%a8%80%e7%b1%bb%e4%bc%bc%e7%9a%84%e6%a6%82%e5%bf%b5" class="anchor">🔗</a></h2><ul>
<li>变量
<ul>
<li>可变性。 变量默认immutable不可变</li>
<li>constants。声明时不用let用const。必须指明类型。const HOUR_IN_SECONDS: u32 = 60 * 60;</li>
<li>shadowing。变量遮挡。</li>
</ul>
</li>
<li>数据类型
<ul>
<li>rust是静态类型语言，编译期需要知道类型</li>
<li>基本类型u32， i32， isize，usize， char。。。</li>
<li>复合类型tuple（fix size，diff type，anomy）， array（fix size，same type），struct（），enum。。。</li>
</ul>
</li>
<li>函数</li>
<li>注释
<ul>
<li>普通注释</li>
<li>文档注释</li>
</ul>
</li>
<li>控制流， if else, for, while, loop, break, continue， goto。</li>
</ul>
<h2 id="4-所有权ownership">4 所有权ownership <a href="#4-%e6%89%80%e6%9c%89%e6%9d%83ownership" class="anchor">🔗</a></h2><pre tabindex="0"><code>ownership, a feature that makes Rust different from other languages. 
make memory safety guarantees without needing a garbage collector,
</code></pre><p>how Rust lays data out in memory. <br></p>
<p>stack &amp; heap -&gt; data on stack must fix-sized. <br></p>
<p>&amp;str (on text seg) vs String (on heap, mutable).<br>
String类型的变量是智能指针在stack上，包含3部分（ptr to heap addr, len, capacity）。</p>
<p><strong>shallow copy: copying the data on the pointer, length, and capacity without copying the data on heap </strong>  <strong>deep copy<strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> s1; <span style="color:#75715e">// 不仅仅是浅拷贝了s1， 而且invalid s1。 称为move。
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> s1.clone(); <span style="color:#75715e">//  deeply copy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
</span></span></code></pre></div><p><code>trait Copy</code>在栈上存储的数据类型实现了Copy trait， 需要move时执行的是copy。例如：  <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9f6b7e4366b96713af039f4531e8da98" target="_blank" rel="noopener">栈上的基本类型数组也实现了Copy trait</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> x; <span style="color:#75715e">// Stack-Only Data: deep and shallow copying is same.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;x = {}, y = {}&#34;</span>, x, y);
</span></span></code></pre></div><pre tabindex="0"><code>Rust won’t let us annotate a type with Copy if the type, or any of its parts, has implemented the Drop trait.
</code></pre><p>持有所有权的变量离开scope时，释放内存<a href="https://doc.rust-lang.org/stable/std/ops/trait.Drop.html#tymethod.drop" target="_blank" rel="noopener">drop</a> ，与C++的Resource Acquisition Is Initialization (RAII)类似。<br></p>
<p>ownership &amp; function. <br></p>
<p>borrowing == reference <br>
rust中所用的参数传递都是传值。 引用实现了copy trait。 按照copy语义，引用会复制一份交给调用的函数。
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=14d37d992ace5e53031eb2c88efe6cfe" target="_blank" rel="noopener">[char; 2] is Copy (as is any [T; N] where T: Copy).</a>。<br>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=008f91de3d0e88ccb5944768fef05c80" target="_blank" rel="noopener">[string; 2]不能被自动copy。</a>
borrow checker, . <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes" target="_blank" rel="noopener">calculate overlap</a></p>
<p>ref &amp;, deref *<br></p>
<p>slices == [T] -&gt; DST, 单单切片类型[T]是不知道长度的，所以&amp;[T]生成智能指针(ptr + len)就可以使用了<br>
数组的切片，字符串的切片都是类似。 &amp;[i32;9], &amp;String, &amp;str， &amp;Vec<i32> ... <br></p>
<pre tabindex="0"><code>A slice is a kind of reference, let you reference a contiguous sequence of elements in a collection
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> ch <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;北京&#34;</span>.chars().nth(<span style="color:#ae81ff">0</span>).unwrap();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;{ch}&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> chbyte <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;北京&#34;</span>.bytes().nth(<span style="color:#ae81ff">0</span>).unwrap();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;{chbyte}&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello world&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> world <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s[<span style="color:#ae81ff">6</span><span style="color:#f92672">..</span><span style="color:#ae81ff">11</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;你好&#34;</span>)<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> ni <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// error, 2不是[utf-8的字符边界]。
</span></span></span></code></pre></div><p><a href="https://doc.rust-lang.org/stable/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings" target="_blank" rel="noopener">utf-8的字符边界</a><br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> string: String <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;string addr = {:?}&#34;</span>, string.as_ptr());
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;string len = {:?}&#34;</span>, string.len());
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;string cap = {:?}&#34;</span>, string.capacity());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// String == struct{ptr, len, cap} on stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;{:x?}&#34;</span>, <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            std::mem::transmute::<span style="color:#f92672">&lt;</span>String, [<span style="color:#66d9ef">u8</span>; std::mem::size_of::<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>()]<span style="color:#f92672">&gt;</span>(string)
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// &amp;str == struct{ptr, len}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;str addr = {:?}&#34;</span>, <span style="color:#66d9ef">str</span>.as_ptr());
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;str len = {:?}&#34;</span>, <span style="color:#66d9ef">str</span>.len());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// println!(&#34;str cap = {:?}&#34;, str.capacity());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;{:x?}&#34;</span>, <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            std::mem::transmute::<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span>, [<span style="color:#66d9ef">u8</span>; std::mem::size_of::<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span>()]<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">str</span>)
</span></span><span style="display:flex;"><span>        });
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">first_word</span>(s: <span style="color:#66d9ef">&amp;</span>String) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bytes <span style="color:#f92672">=</span> s.as_bytes();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i, <span style="color:#f92672">&amp;</span>item) <span style="color:#66d9ef">in</span> bytes.iter().enumerate() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> item <span style="color:#f92672">==</span> <span style="color:#e6db74">b&#39; &#39;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>s[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>s[<span style="color:#f92672">..</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>string Literals are Slices<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, world!&#34;</span>; <span style="color:#75715e">//&amp;str is an immutable reference. a slice pointing to that specific point of the binary.
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">first_word</span>(s: <span style="color:#66d9ef">&amp;</span>String) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">first_word</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {} <span style="color:#75715e">//  both &amp;String values and &amp;str values can call
</span></span></span></code></pre></div><h2 id="5结构体struct">5结构体struct <a href="#5%e7%bb%93%e6%9e%84%e4%bd%93struct" class="anchor">🔗</a></h2><p>3类结构体。 struct A {}; struct B (); struct C;</p>
<p>tuple struct</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Color</span>(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> black <span style="color:#f92672">=</span> Color(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AlwaysEqual</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> subject <span style="color:#f92672">=</span> AlwaysEqual; <span style="color:#75715e">//unit-like structs. useful for implement a trait on some type, don’t have any data to store in the type
</span></span></span></code></pre></div><p>struct中的field拥有所有权时，field对象的生命周期 == struct对象的生命周期。<br>
struct中的field中type是String， 或者type是&amp;str。<br>
当field是引用类型时，struct类型需要保证struct对象的生命周期 &lt;= 依赖的引用类型对象的生命周期。所以需要引入lifetime标识符。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">User</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    active: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    username: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    email: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    sign_in_count: <span style="color:#66d9ef">u64</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
</span></span><span style="display:flex;"><span>    width: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>    height: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> scale <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rect1 <span style="color:#f92672">=</span> Rectangle {
</span></span><span style="display:flex;"><span>        width: <span style="color:#ae81ff">30</span>,
</span></span><span style="display:flex;"><span>        height: <span style="color:#a6e22e">dbg</span><span style="color:#f92672">!</span>(scale <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>), <span style="color:#75715e">// dbg! return the ownership of the expression’s value and print expression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;rect1 is {}&#34;</span>, rect1);  <span style="color:#75715e">// error[E0277]: `Rectangle` doesn&#39;t implement `std::fmt::Display`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;rect1 is {:?}, {:#?}&#34;</span>, rect1, rect1); <span style="color:#75715e">//error[E0277]: `Rectangle` doesn&#39;t implement `Debug`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// solved: #[derive(Debug)]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>dbg!(<span style="color:#f92672">&amp;</span>rect1);
</span></span></code></pre></div><p>automatic referencing and dereferencing. <br>
Rust automatically adds in &amp;, &amp;mut, or * to matches the signature of the method.<br></p>
<h2 id="6枚举体enum-和-模式匹配">6枚举体enum 和 模式匹配 <a href="#6%e6%9e%9a%e4%b8%be%e4%bd%93enum-%e5%92%8c-%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d" class="anchor">🔗</a></h2><p>枚举类型的值范围是固定可枚举的。模式匹配。<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html" target="_blank" rel="noopener">Option</a>, match, if let。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    None,
</span></span><span style="display:flex;"><span>    Some(T),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>模式匹配 match需要<code>fill all arms, exhaustive patterns</code>。如果只关心其中一个pattern，使用<code>if let</code> <code>while let</code>。<br></p>
<p><strong>默认的匹配是绑定操作， 会转移所有权。</strong><br>
<strong>以引用方式去匹配, <code>ref</code>可以在匹配时获得一个变量的引用</storng><br></p>
<h2 id="7-project-packagecrate-module">7 Project, package,crate, module <a href="#7-project-packagecrate-module" class="anchor">🔗</a></h2><p>如何组织rust项目的代码？<br></p>
<ul>
<li>Packages: A Cargo feature that lets you build, test, and share crates, Cargo.toml
<ul>
<li>一个package下可有多个bin crates， <strong>src/main.rs</strong>； 如果有<strong>src/bin有rs文件，each file will be a separate binary crate</strong>。</li>
<li>但最多一个lib crates， src/lib.rs。</li>
</ul>
</li>
<li>Crates:  A tree of modules that produces a library or executable, src/main.rs or src/lib.rs</li>
<li>Modules and use: Let you control the organization, scope, and privacy of paths
+</li>
<li>Paths:  A way of naming an item, such as a struct, function, or module
+</li>
</ul>
<h2 id="8-常见的集合">8 常见的集合 <a href="#8-%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9b%86%e5%90%88" class="anchor">🔗</a></h2><ul>
<li>vector 动态扩容数组</li>
<li>String 字符的集合，字符串</li>
<li>HashMap</li>
</ul>
<p><a href="https://doc.rust-lang.org/stable/std/collections/index.html" target="_blank" rel="noopener">其他数据集合</a><br></p>
<h3 id="vect">Vec<T> <a href="#vect" class="anchor">🔗</a></h3><p><a href="">std::vec::Vec</a><br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#75715e">// create
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// infer the type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Updating a Vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>    v.push(<span style="color:#ae81ff">4</span>);v.push(<span style="color:#ae81ff">5</span>);v.push(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Reading Elements of Vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#75715e">// via indexing or using the get method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> third: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> third: Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> v.get(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> third {
</span></span><span style="display:flex;"><span>        Some(third) <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;The third element is {third}&#34;</span>),
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;There is no third element.&#34;</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Iterating over the Values in a Vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">57</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>v { <span style="color:#75715e">// immutable reference to each element ， type of i is &amp;i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        println!(<span style="color:#e6db74">&#34;{i}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">57</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> v { <span style="color:#75715e">// mutable reference, type of i is &amp;mut i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">50</span>;     <span style="color:#75715e">// * dereference operator to get to the value in i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Using an Enum to Store Multiple Types
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">SpreadsheetCell</span> {
</span></span><span style="display:flex;"><span>        Int(<span style="color:#66d9ef">i32</span>),
</span></span><span style="display:flex;"><span>        Float(<span style="color:#66d9ef">f64</span>),
</span></span><span style="display:flex;"><span>        Text(String),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> row <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>        SpreadsheetCell::Int(<span style="color:#ae81ff">3</span>),
</span></span><span style="display:flex;"><span>        SpreadsheetCell::Text(String::from(<span style="color:#e6db74">&#34;blue&#34;</span>)),
</span></span><span style="display:flex;"><span>        SpreadsheetCell::Float(<span style="color:#ae81ff">10.12</span>),
</span></span><span style="display:flex;"><span>    ];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// using trait object to store in vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>more details at “The Rustonomicon”。</p>
<h3 id="utf-8-encoding-in-string">UTF-8 encoding in String <a href="#utf-8-encoding-in-string" class="anchor">🔗</a></h3><p>在core包中只定义了str类型，以引用的形式出现&amp;str。<br>
在std包中定义了String类型，a growable, mutable, owned, <strong>UTF-8 encoded</strong> string type。
[]byte 。A String is  a wrapper over a Vec<u8>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#75715e">// create
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;initial contents&#34;</span>.to_string(); <span style="color:#75715e">// string literals  implements the Display trait (define to_string)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;initial contents&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Updating a String
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span>    s.push_str(<span style="color:#e6db74">&#34;bar&#34;</span>);
</span></span><span style="display:flex;"><span>    s.push(<span style="color:#e6db74">&#39;l&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Concatenation with the + Operator or the format! Macro
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world!&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// fn add(self, s: &amp;str) -&gt; String ... coerce the &amp;String argument into a &amp;str
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2; <span style="color:#75715e">// note s1 has been moved here and can no longer be used
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;{s2}{s3}&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Indexing into Strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// error....`String` cannot be indexed by `{integer}`  UTF-8中有效字符不是一个字节，index at i 可能是乱码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> s1[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Slicing Strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Здравствуйте&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>hello[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">4</span>];  <span style="color:#75715e">//s == &#34;3&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>hello[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1</span>];  <span style="color:#75715e">//panic, `1` is not a `char boundary`; it is inside &#39;З&#39; (bytes 0..2) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Methods for Iterating Over Strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;Зд&#34;</span>.chars() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;{c}&#34;</span>); <span style="color:#75715e">// З \n д \n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> b <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;Зд&#34;</span>.bytes() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;{b}&#34;</span>); <span style="color:#75715e">// 208 \n 151 \n 208 \n 180
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }   
</span></span></code></pre></div><h3 id="hashmapk-v">HashMap&lt;K, V&gt; <a href="#hashmapk-v" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#75715e">//create
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// not ofen use, so not in the prelude
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    scores.insert(String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>), <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    scores.insert(String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>), <span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// standard lib less support, no built-in macro to construct them.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Accessing Values in a Hash Map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> team_name <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> score <span style="color:#f92672">=</span> scores.get(<span style="color:#f92672">&amp;</span>team_name).copied().unwrap_or(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (key, value) <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>scores {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;{}: {}&#34;</span>, key, value);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Hash Maps and Ownership
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Adding a Key and Value Only If a Key Isn’t Present
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    scores.entry(String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>)).or_insert(<span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Updating a Value Based on the Old Value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world wonderful world&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> word <span style="color:#66d9ef">in</span> text.split_whitespace() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> count <span style="color:#f92672">=</span> map.entry(word).or_insert(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">//or_insert method returns a mutable reference (&amp;mut V) to the value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span></code></pre></div><h3 id="其他数据集合">其他数据集合 <a href="#%e5%85%b6%e4%bb%96%e6%95%b0%e6%8d%ae%e9%9b%86%e5%90%88" class="anchor">🔗</a></h3><p>链表。<br></p>
<hr>
<h2 id="9-错误处理">9 错误处理 <a href="#9-%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" class="anchor">🔗</a></h2><p>recover from an error or to stop execution? <br></p>
<h3 id="unrecoverable-errors-panic">unrecoverable errors panic! <a href="#unrecoverable-errors-panic" class="anchor">🔗</a></h3><p><a href="">panic!</a><br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//RUST_BACKTRACE=1 cargo run
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// RUST_BACKTRACE=full cargo run
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    v[<span style="color:#ae81ff">99</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="recoverable-errors-resultt-e">recoverable errors Result&lt;T, E&gt; <a href="#recoverable-errors-resultt-e" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Ok(T),
</span></span><span style="display:flex;"><span>    Err(E),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::fs::File;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::io::ErrorKind;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting_file_result <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting_file <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> greeting_file_result {
</span></span><span style="display:flex;"><span>        Ok(file) <span style="color:#f92672">=&gt;</span> file,
</span></span><span style="display:flex;"><span>        Err(error) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> error.kind() {
</span></span><span style="display:flex;"><span>            ErrorKind::NotFound <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> File::create(<span style="color:#e6db74">&#34;hello.txt&#34;</span>) {
</span></span><span style="display:flex;"><span>                Ok(fc) <span style="color:#f92672">=&gt;</span> fc,
</span></span><span style="display:flex;"><span>                Err(e) <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;Problem creating the file: {:?}&#34;</span>, e),
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            other_error <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                panic!(<span style="color:#e6db74">&#34;Problem opening the file: {:?}&#34;</span>, other_error);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::fs::File;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::io::ErrorKind;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting_file <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>).unwrap_or_else(<span style="color:#f92672">|</span>error<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> error.kind() <span style="color:#f92672">==</span> ErrorKind::NotFound {
</span></span><span style="display:flex;"><span>            File::create(<span style="color:#e6db74">&#34;hello.txt&#34;</span>).unwrap_or_else(<span style="color:#f92672">|</span>error<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                panic!(<span style="color:#e6db74">&#34;Problem creating the file: {:?}&#34;</span>, error);
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            panic!(<span style="color:#e6db74">&#34;Problem opening the file: {:?}&#34;</span>, error);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Shortcuts for Panic on Error: <strong>unwrap()</strong> and <strong>expect(&quot;infos&quot;)</strong> <br></p>
<p>Propagating Errors: ? <br>
? after a Result value. From trait and from function. <br>
? after Option value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::fs::File;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting_file <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::error::Error;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::fs::File;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Error<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting_file <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;hello.txt&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>the ? operator in a function that must returns Result, Option, or another type that implements FromResidual <br>
main的return type implement <a href="https://doc.rust-lang.org/stable/std/process/trait.Termination.html" target="_blank" rel="noopener">the std::process::Termination trait</a><br></p>
<h2 id="10-泛型trait生命周期">10 泛型，trait，生命周期 <a href="#10-%e6%b3%9b%e5%9e%8btrait%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" class="anchor">🔗</a></h2><p>生命周期。 即引用的有效作用域。</p>
<h3 id="泛泛的数据类型">泛泛的数据类型 <a href="#%e6%b3%9b%e6%b3%9b%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" class="anchor">🔗</a></h3><p>concrete types VS generic types -&gt; reduce code duplication.<br>
Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">largest</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">std</span>::cmp::PartialOrd<span style="color:#f92672">&gt;</span>(list: <span style="color:#66d9ef">&amp;</span>[T]) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> largest <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>list[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> list {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> item <span style="color:#f92672">&gt;</span> largest {
</span></span><span style="display:flex;"><span>            largest <span style="color:#f92672">=</span> item;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    largest
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// in struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    x: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>    y: <span style="color:#a6e22e">U</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// in enum
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Some(T),
</span></span><span style="display:flex;"><span>    None,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Ok(T),
</span></span><span style="display:flex;"><span>    Err(E),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="trait-定义通用共享的行为">trait 定义通用、共享的行为 <a href="#trait-%e5%ae%9a%e4%b9%89%e9%80%9a%e7%94%a8%e5%85%b1%e4%ba%ab%e7%9a%84%e8%a1%8c%e4%b8%ba" class="anchor">🔗</a></h3><p>trait为类型定义通用、共享的行为。trait也可以限制泛型类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 定义trait类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">trait</span> A {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span>(<span style="color:#f92672">&amp;</span>self);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 可以有默认的函数实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">bar</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
</span></span><span style="display:flex;"><span>        String::from(<span style="color:#e6db74">&#34;bar&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在类型Type_B上实现trait A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> A <span style="color:#66d9ef">for</span> Type_B {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span>(<span style="color:#f92672">&amp;</span>self) {<span style="color:#f92672">..</span>.};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// trait作为参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">C</span>(item: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">impl</span> A) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//accepts any type that implements the specified trait A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;hi, i have implement trait A, {}&#34;</span>, item.bar());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  trait bound;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(item: <span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;{}&#34;</span>, item.bar());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Returning Types that impl trait. must returning a single implement trait type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// especially useful in the context of closures and iterators,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//为实现了Display trait的类型实现ToString trait
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Display</span><span style="color:#f92672">&gt;</span> ToString <span style="color:#66d9ef">for</span> T {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// --snip--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.</span>to_string(); <span style="color:#75715e">//任何实现了Display的类型的对象可调用to_string方法。
</span></span></span></code></pre></div><h3 id="检查引用借用有效性--生命周期">检查引用(借用)有效性--生命周期 <a href="#%e6%a3%80%e6%9f%a5%e5%bc%95%e7%94%a8%e5%80%9f%e7%94%a8%e6%9c%89%e6%95%88%e6%80%a7--%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" class="anchor">🔗</a></h3><p><a href="">Borrow Checker</a><br> 为了避免dangling references。
Lifetime Annotations in function Definitions<br>
Lifetime Annotations in Struct Definitions<br>
lifetime elision rules<br></p>
<p>如何计算每个变量的生命周期, a_ref的life time[4 - 9]-&gt; a life time [code 2 - 10] (区间是包含关系) ✅</p>
<p>x的'a &gt;  y的'b， x = &amp;y (❌) <br>
x的'a &lt;= y的'b, x = &amp;y (yes) <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;I have a static lifetime.&#34;</span>;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hi&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;world&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> largest <span style="color:#f92672">=</span> get_largest(s1, s2);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;largest: {}&#34;</span>, largest);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_largest</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>(s1: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>, s2: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> s1.len() <span style="color:#f92672">&gt;</span> s2.len() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    s2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://practice.rs/lifetime/static.html" target="_blank" rel="noopener">&amp;'static and T: 'static</a> <br></p>
<p>&amp;'static类型的值出现的两种方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello,world&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Box::leak(Box::new(a));
</span></span></code></pre></div><p><strong>Generic Type Parameters, Trait Bounds, and Lifetimes Together</strong> look a little complex, but all features happen at the compile time, no effect on runtime time.</p>
<h2 id="11-测试">11 测试 <a href="#11-%e6%b5%8b%e8%af%95" class="anchor">🔗</a></h2><p>[type checking and borrow checking]不能检查程序的内部逻辑的正确性，所以引入testing。<br>
rust testing中有好用的annotations和macros，以及如何组织单元测试，集成测试。<br></p>
<p>#[test]将函数变为测试函数。</p>
<pre tabindex="0"><code>$cargo test 
running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


0 ignored -&gt; #[should_ignore]
0 measured -&gt;  for benchmark tests 
0 filtered out -&gt; pass an argument to the cargo test command to run special tests 

Doc-tests adder -&gt; documentation tests.
</code></pre><p>assert_eq!, assert_ne! macros 用到了 operators == and !=， 所以参数需要实现PartialEq trait。 同时fail后，需要打印Debug format的信息，也需要实现Debug trait。基本类型已经实现了这2个trait。struct 和 enum类型需要自行实现，或者#[derive(PartialEq, Debug)]。</p>
<p>cargo test的一些参数选项可以控制单测的执行。<br>
show the output of successful tests:   cargo test -- --show-output. <br>
Runn Single Tests: cargo test single_func_name <br>
Run only the ignored tests: cargo test -- --ignored <br></p>
<p>如何组织测试代码？unit tests and integration tests<br></p>
<p>#[cfg(test)] 只会在cargo test下执行，避免拖慢编译速度。
tests/下 放集成测试文件，不需要#[cfg(test)]。
cargo test的测试执行顺序是 tests/ 集成测试 -&gt; 单元测试 -&gt; 文档测试。<br></p>
<h2 id="12-project-io-code">12 project: io code <a href="#12-project-io-code" class="anchor">🔗</a></h2><p><a href="">done</a><br></p>
<h2 id="13-函数编程语言的特点-iterator-closure">13 函数编程语言的特点： Iterator, closure <a href="#13-%e5%87%bd%e6%95%b0%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e7%9a%84%e7%89%b9%e7%82%b9-iterator-closure" class="anchor">🔗</a></h2><h3 id="闭包">闭包 <a href="#%e9%97%ad%e5%8c%85" class="anchor">🔗</a></h3><p>匿名函数，携带环境变量。</p>
<p>FnOnce (grand parent) -&gt; FnMut (parent) -&gt; Fn (child) <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unwrap_or_else</span>(<span style="color:#f92672">&amp;</span>self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">T</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> F: FnOnce() -&gt; <span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            Some(x) <span style="color:#f92672">=&gt;</span> x,
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> f(), <span style="color:#75715e">//all closures implement FnOnce
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a: Option<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>a.unwrap_or_else(Vec::new); 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive[Debug]]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
</span></span><span style="display:flex;"><span>    width: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>    height: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> arr <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    Rectangle{width: <span style="color:#ae81ff">10</span>, height: <span style="color:#ae81ff">1</span>},
</span></span><span style="display:flex;"><span>    Rectangle{width: <span style="color:#ae81ff">3</span>, height: <span style="color:#ae81ff">5</span>},
</span></span><span style="display:flex;"><span>    Rectangle{width: <span style="color:#ae81ff">7</span>, height: <span style="color:#ae81ff">12</span>},
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num_sort_operations <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>arr.sort_by_key(<span style="color:#f92672">|</span>r<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    num_sort_operations <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    r.width}); <span style="color:#75715e">//uses FnMut
</span></span></span></code></pre></div><h3 id="迭代器">迭代器 <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8" class="anchor">🔗</a></h3><p>很多迭代器的函数参数都是闭包。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> v_iter <span style="color:#f92672">=</span> v.iter(); <span style="color:#75715e">//lazy and do nothing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> v_iter {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Got: {item}&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>v_iter.next(); <span style="color:#75715e">//error
</span></span></span></code></pre></div><p>所有的迭代器实现了trait Iterator。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Iterator {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span> , <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// v1.into_iter(), v1.iter_mut()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v1_iter <span style="color:#f92672">=</span> v1.iter(); <span style="color:#75715e">// should mut, for item in v_iter take Ownership
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>assert_eq!(v1_iter.next(), Some(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>assert_eq!(v1_iter.next(), Some(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>assert_eq!(v1_iter.next(), Some(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">3</span>));
</span></span><span style="display:flex;"><span>assert_eq!(v1_iter.next(), None);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// sum()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> total: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> v1_iter.sum(); <span style="color:#75715e">// take ownership
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// iterator adaptor map(), returns a new iterator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v1: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>v1.iter().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">//lazy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// filter()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// collect()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v2: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> v1.iter().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>).collect();
</span></span></code></pre></div><hr>
<p>loop vs iterator<br></p>
<h2 id="14-cargo--cratesio">14 cargo &amp; crates.io <a href="#14-cargo--cratesio" class="anchor">🔗</a></h2><p><a href="https://doc.rust-lang.org/cargo/" target="_blank" rel="noopener">The Cargo Book</a><br></p>
<h3 id="cargotoml">Cargo.toml <a href="#cargotoml" class="anchor">🔗</a></h3><pre tabindex="0"><code>[profile.dev]
opt-level = 0
[profile.release]
opt-level = 3
</code></pre><h3 id="发布到cratesio">发布到crates.io <a href="#%e5%8f%91%e5%b8%83%e5%88%b0cratesio" class="anchor">🔗</a></h3><p>文档注释， <strong>cargo doc --open</strong> 查看本项目的文档注释对应的html文档。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// # Examples 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// # Panics
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// # Safety
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// # Errors
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">// 文档测试
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//！ 
</span></span></span></code></pre></div><p>Exporting a Convenient Public API with <strong>pub use</strong> <br>
use my_crate::some_module::another_module::UsefulType; -&gt; use my_crate::UsefulType;<br>
在一个library A的src/lib.rs中<strong>pub use A::B::C::D;</strong> 可以在其他项目中使用<strong>use A::D</strong>导入到scope中。<br></p>
<p>在crates.io上创建账号并获取token。 cargo login token11222<br>
更改toml文件中的cargo publish<br></p>
<h3 id="workspace组织项目">workspace组织项目 <a href="#workspace%e7%bb%84%e7%bb%87%e9%a1%b9%e7%9b%ae" class="anchor">🔗</a></h3><p>一个workspace下管理多个文件夹，<strong>共享同一个Cargo.lock和output target目录</strong><br>
例如一个workspace下包含一个bin和2个libraries。workspace: add -&gt; (bin: adder, lib: add_one, add_two)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">$</span> mkdir add
</span></span><span style="display:flex;"><span><span style="color:#75715e">$</span> cd add
</span></span><span style="display:flex;"><span><span style="color:#75715e">// touch and edit Cargo.toml
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[workspace]
</span></span><span style="display:flex;"><span>members <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;adder&#34;</span>]
</span></span><span style="display:flex;"><span><span style="color:#75715e">// under the add workspace directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">$</span> cargo new adder
</span></span><span style="display:flex;"><span>     Created binary (application) <span style="color:#960050;background-color:#1e0010">`</span>adder<span style="color:#960050;background-color:#1e0010">`</span> package
</span></span><span style="display:flex;"><span><span style="color:#75715e">$</span> cargo build 
</span></span></code></pre></div><p>现在workspace add目录下的结构：<br>
├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>[workspace]
</span></span><span style="display:flex;"><span>members <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;adder&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;add_one&#34;</span>,
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span><span style="color:#75715e">// under the add workspace directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">$</span> cargo new add_one <span style="color:#f92672">--</span>lib
</span></span><span style="display:flex;"><span>     Created library <span style="color:#960050;background-color:#1e0010">`</span>add_one<span style="color:#960050;background-color:#1e0010">`</span> package
</span></span></code></pre></div><p>├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target</p>
<p>edit add_one/src/lib.rs</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// add_one/src/lib.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add_one</span>(x: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在adder crate中增加对add_one lib crate的依赖。</p>
<pre tabindex="0"><code>Filename: adder/Cargo.toml

[dependencies]
add_one = { path = &#34;../add_one&#34; }
</code></pre><p>edit Filename: adder/src/main.rs</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> add_one;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Hello, world! {num} plus one is {}!&#34;</span>, add_one::add_one(num));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在workspace add目录下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">$</span> cargo run <span style="color:#f92672">-</span>p adder
</span></span><span style="display:flex;"><span>    Finished dev [unoptimized <span style="color:#f92672">+</span> debuginfo] target(s) <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.0</span>s
</span></span><span style="display:flex;"><span>     Running <span style="color:#960050;background-color:#1e0010">`</span>target<span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>adder<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>Hello, world<span style="color:#f92672">!</span> <span style="color:#ae81ff">10</span> plus one is <span style="color:#ae81ff">11</span><span style="color:#f92672">!</span>
</span></span></code></pre></div><p>由于workspace下的crate共享了Cargo.lock。all crates are using the same version of all dependencies<br></p>
<pre tabindex="0"><code>// add_one/Cargo.toml
[dependencies]
rand = &#34;0.8.3&#34;
</code></pre><p>如需要publish workspace下的crate到crate.io，需要publish -p 分开发布。<br></p>
<h3 id="从cratesio上安装软件">从crates.io上安装软件 <a href="#%e4%bb%8ecratesio%e4%b8%8a%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" class="anchor">🔗</a></h3><p>cargo install 方面从crates.io上安装工具，并安装在$HOME/.cargo/</p>
<pre tabindex="0"><code>$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
$ rg --help
</code></pre><h3 id="扩展cargo的子命令">扩展cargo的子命令 <a href="#%e6%89%a9%e5%b1%95cargo%e7%9a%84%e5%ad%90%e5%91%bd%e4%bb%a4" class="anchor">🔗</a></h3><p>如果在$PATh下有一个‘cargo-something’的exe，能够像cargo subcommand方式运行，‘cargo something’。
cargo --list<br></p>
<h2 id="15-智能指针">15 智能指针 <a href="#15-%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" class="anchor">🔗</a></h2><p>通过struct实现，包含指针+meta信息，struct也实现<font color=blue><strong>Deref, Drop trait</strong></font>。 引用仅仅只是借用数据。指针指针可以own数据。<br>
<strong>String, Vec<T></strong>是智能指针。<br></p>
<ul>
<li>Box<T> allocatie value of type T on heap，单所有权</li>
<li>Rc<T> enables multiple ownership 多所有权， only immutable borrow</li>
<li>Ref<T>, RefMut<T>, RefCell<T>， 单所有权  the borrowing rules at runtime</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// implements the Deref trait, which allows Box&lt;T&gt; values to be treated like references
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;b = {}&#34;</span>, b);
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;deref b = {}&#34;</span>,<span style="color:#f92672">*</span>b); <span style="color:#75715e">// *b == *(b.deref())  deref() 返回的是item的引用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//必须使用Box才能定义这些类型。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>    Cons(<span style="color:#66d9ef">i32</span>, List), <span style="color:#75715e">// fail compile。 (1, (2, (3, Nil)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用Box定义带有递归的类型（有一个字段的类型和自己有相同的类型）。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>    Cons(<span style="color:#66d9ef">i32</span>, Box<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> list <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">1</span>, Box::new(Cons(<span style="color:#ae81ff">2</span>, Box::new(Cons(<span style="color:#ae81ff">3</span>, Box::new(Nil))))));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//因为smart pointer实现Deref trait，可以compiler做 dereference operator * 进而与普通引用一样使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// deref coercion， &amp;String -&gt; &amp;str, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hello</span>(name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;hello: {name}&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> m <span style="color:#f92672">=</span> Box::new(String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&amp;Box&lt;String&gt; --Box impl Defref--&gt; &amp;String --String impl Defref--&gt; &amp;str --&gt; type matching.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// or manually, &amp;(*m)[..] 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>hello(<span style="color:#f92672">&amp;</span>m);
</span></span></code></pre></div><p>deref coercion<br></p>
<ul>
<li>from &amp;T to &amp;U when T: Deref&lt;Target=U&gt;</li>
<li>from &amp;mut T to &amp;mut U when T: DefrefMut&lt;Target=U&gt;</li>
<li>from &amp;mut T to &amp;U when T: Defref&lt;Target=U&gt;</li>
</ul>
<p>std::mem::drop在prelude里， drop(x) 可提前释放内存。<br></p>
<p><strong><font color=blue>Rc<T> 引用计数的智能指针  </font></strong><br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">5</span>, Box::new(Cons(<span style="color:#ae81ff">10</span>, Box::new(Nil))));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">3</span>, Box::new(a)); <span style="color:#75715e">// Box::new() take ownership
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">4</span>, Box::new(a)); <span style="color:#75715e">// failed, use of moved value: `a`
</span></span></span></code></pre></div><p>instead</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::Rc; <span style="color:#75715e">//not in the prelude
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>    Cons(<span style="color:#66d9ef">i32</span>, Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::new(Cons(<span style="color:#ae81ff">5</span>, Rc::new(Cons(<span style="color:#ae81ff">10</span>, Rc::new(Nil)))));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">3</span>, Rc::clone(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">4</span>, Rc::clone(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;after clone, rc count = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// immutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Drop trait decreases the reference count on  Rc&lt;T&gt; value
</span></span></span></code></pre></div><p><strong>RefCell<T></strong> <br>
mutate data even when there are immutable references to that data, use <code>unsafe code</code> inside <br>
在编译期间检查是保守的，可能会reject一些正确的程序。RefCell类型的变量在runtime时进行借用检查，失败会panic。<br>
<strong> interior mutability</strong>: an immutable type exposes an API for mutating an interior value.<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>    Cons(Rc<span style="color:#f92672">&lt;</span>RefCell<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span>, Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::RefCell;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::Rc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> value <span style="color:#f92672">=</span> Rc::new(RefCell::new(<span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::new(Cons(Rc::clone(<span style="color:#f92672">&amp;</span>value), Rc::new(Nil)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(Rc::new(RefCell::new(<span style="color:#ae81ff">3</span>)), Rc::clone(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(Rc::new(RefCell::new(<span style="color:#ae81ff">4</span>)), Rc::clone(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>value.borrow_mut() <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;a after = {:?}&#34;</span>, a);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;b after = {:?}&#34;</span>, b);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;c after = {:?}&#34;</span>, c);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  a after = Cons(RefCell { value: 15 }, Nil)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>reference cycles -&gt; leak memory <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::RefCell;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::Rc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>    Cons(<span style="color:#66d9ef">i32</span>, RefCell<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;&gt;</span>),
</span></span><span style="display:flex;"><span>    Nil,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> List {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tail</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span>RefCell<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            Cons(_, item) <span style="color:#f92672">=&gt;</span> Some(item),
</span></span><span style="display:flex;"><span>            Nil <span style="color:#f92672">=&gt;</span> None,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::new(Cons(<span style="color:#ae81ff">5</span>, RefCell::new(Rc::new(Nil))));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;a initial rc count = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;a next item = {:?}&#34;</span>, a.tail());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Rc::new(Cons(<span style="color:#ae81ff">10</span>, RefCell::new(Rc::clone(<span style="color:#f92672">&amp;</span>a))));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;a rc count after b creation = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;b initial rc count = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>b));
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;b next item = {:?}&#34;</span>, b.tail());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(link) <span style="color:#f92672">=</span> a.tail() {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>link.borrow_mut() <span style="color:#f92672">=</span> Rc::clone(<span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;b rc count after changing a = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>b));
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;a rc count after changing a = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Uncomment the next line to see that we have a cycle;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// it will overflow the stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// println!(&#34;a next item = {:?}&#34;, a.tail());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>weak reference, Rc::downgrade, Weak<T></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::RefCell;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::Rc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> { <span style="color:#75715e">// 树上节点的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    value: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    children: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> leaf <span style="color:#f92672">=</span> Rc::new(Node {
</span></span><span style="display:flex;"><span>        value: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>        children: <span style="color:#a6e22e">RefCell</span>::new(vec![]),
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> branch <span style="color:#f92672">=</span> Rc::new(Node {
</span></span><span style="display:flex;"><span>        value: <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>        children: <span style="color:#a6e22e">RefCell</span>::new(vec![Rc::clone(<span style="color:#f92672">&amp;</span>leaf)]),
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::RefCell;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::{Rc, Weak};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    parent: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Weak<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    children: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::RefCell;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::{Rc, Weak};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    parent: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Weak<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    children: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> leaf <span style="color:#f92672">=</span> Rc::new(Node {
</span></span><span style="display:flex;"><span>        value: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>        parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
</span></span><span style="display:flex;"><span>        children: <span style="color:#a6e22e">RefCell</span>::new(vec![]),
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// leaf parent = None
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;leaf parent = {:?}&#34;</span>, leaf.parent.borrow().upgrade());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> branch <span style="color:#f92672">=</span> Rc::new(Node {
</span></span><span style="display:flex;"><span>        value: <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>        parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
</span></span><span style="display:flex;"><span>        children: <span style="color:#a6e22e">RefCell</span>::new(vec![Rc::clone(<span style="color:#f92672">&amp;</span>leaf)]),
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>leaf.parent.borrow_mut() <span style="color:#f92672">=</span> Rc::downgrade(<span style="color:#f92672">&amp;</span>branch);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//children: RefCell { value: [] } }] } })
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;leaf parent = {:?}&#34;</span>, leaf.parent.borrow().upgrade());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::cell::RefCell;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::{Rc, Weak};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>    parent: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Weak<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    children: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> leaf <span style="color:#f92672">=</span> Rc::new(Node {
</span></span><span style="display:flex;"><span>        value: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>        parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
</span></span><span style="display:flex;"><span>        children: <span style="color:#a6e22e">RefCell</span>::new(vec![]),
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;leaf strong = {}, weak = {}&#34;</span>,
</span></span><span style="display:flex;"><span>        Rc::strong_count(<span style="color:#f92672">&amp;</span>leaf),
</span></span><span style="display:flex;"><span>        Rc::weak_count(<span style="color:#f92672">&amp;</span>leaf),
</span></span><span style="display:flex;"><span>    ); <span style="color:#75715e">//leaf strong = 1, weak = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> branch <span style="color:#f92672">=</span> Rc::new(Node {
</span></span><span style="display:flex;"><span>            value: <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>            parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
</span></span><span style="display:flex;"><span>            children: <span style="color:#a6e22e">RefCell</span>::new(vec![Rc::clone(<span style="color:#f92672">&amp;</span>leaf)]),
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>leaf.parent.borrow_mut() <span style="color:#f92672">=</span> Rc::downgrade(<span style="color:#f92672">&amp;</span>branch);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println!(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;branch strong = {}, weak = {}&#34;</span>,
</span></span><span style="display:flex;"><span>            Rc::strong_count(<span style="color:#f92672">&amp;</span>branch),
</span></span><span style="display:flex;"><span>            Rc::weak_count(<span style="color:#f92672">&amp;</span>branch),
</span></span><span style="display:flex;"><span>        ); <span style="color:#75715e">//branch strong = 1, weak = 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        println!(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;leaf strong = {}, weak = {}&#34;</span>,
</span></span><span style="display:flex;"><span>            Rc::strong_count(<span style="color:#f92672">&amp;</span>leaf),
</span></span><span style="display:flex;"><span>            Rc::weak_count(<span style="color:#f92672">&amp;</span>leaf),
</span></span><span style="display:flex;"><span>        ); <span style="color:#75715e">// leaf strong = 2, weak = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//leaf parent = None
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;leaf parent = {:?}&#34;</span>, leaf.parent.borrow().upgrade());
</span></span><span style="display:flex;"><span>    println!(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;leaf strong = {}, weak = {}&#34;</span>,
</span></span><span style="display:flex;"><span>        Rc::strong_count(<span style="color:#f92672">&amp;</span>leaf),
</span></span><span style="display:flex;"><span>        Rc::weak_count(<span style="color:#f92672">&amp;</span>leaf),
</span></span><span style="display:flex;"><span>    ); <span style="color:#75715e">//leaf strong = 1, weak = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="16-并发">16 并发 <a href="#16-%e5%b9%b6%e5%8f%91" class="anchor">🔗</a></h2><p>无畏并发： 并发问题在编译期间暴露，而为运行时出现后再去花时间去复现，因此让用户无畏惧并发。<br></p>
<h3 id="创建线程">创建线程 <a href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::time::Duration;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    thread::spawn(<span style="color:#f92672">||</span>{
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;i am a thread&#34;</span>);
</span></span><span style="display:flex;"><span>        thread::sleep(Duration::from_millis(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>     thread::sleep(Duration::from_millis(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::time::Duration;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> handle <span style="color:#f92672">=</span> thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Here&#39;s a vector: {:?}&#34;</span>, v);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    handle.join().unwrap();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="线程间的通信message-passing-concurrencyvia-channel">线程间的通信，message-passing concurrency,via channel <a href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1message-passing-concurrencyvia-channel" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>     <span style="color:#66d9ef">use</span> std::{
</span></span><span style="display:flex;"><span>        sync::mpsc::{self, Sender},
</span></span><span style="display:flex;"><span>        thread,
</span></span><span style="display:flex;"><span>        time::Duration,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_channel</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> mpsc::channel();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// let tx1 = tx.clone();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> tx1 <span style="color:#f92672">=</span> Sender::clone(<span style="color:#f92672">&amp;</span>tx);
</span></span><span style="display:flex;"><span>        thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> vals <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;hi&#34;</span>),
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;from&#34;</span>),
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;the&#34;</span>),
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;thread&#34;</span>),
</span></span><span style="display:flex;"><span>            ];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> val <span style="color:#66d9ef">in</span> vals {
</span></span><span style="display:flex;"><span>                tx1.send(val).unwrap();
</span></span><span style="display:flex;"><span>                thread::sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> vals <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;more&#34;</span>),
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;messages&#34;</span>),
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;for&#34;</span>),
</span></span><span style="display:flex;"><span>                String::from(<span style="color:#e6db74">&#34;you&#34;</span>),
</span></span><span style="display:flex;"><span>            ];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> val <span style="color:#66d9ef">in</span> vals {
</span></span><span style="display:flex;"><span>                tx.send(val).unwrap();
</span></span><span style="display:flex;"><span>                thread::sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> received <span style="color:#66d9ef">in</span> rx {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;got: {}&#34;</span>, received);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="线程间共享内存共享状态-shared-state-concurrency">线程间共享内存（共享状态）， shared-state concurrency <a href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e5%85%b1%e4%ba%ab%e7%8a%b6%e6%80%81-shared-state-concurrency" class="anchor">🔗</a></h3><p>已经可以通过channel来通信，另外一种方式是通过共享内存来通信。<br>
channel的方式类似于单一所有权，数据被发送给channel后，所有权就转移到channel上<br>
共享内存的方式类似多个所有权，多个线程可以访问。<br></p>
<p><strong>Mutex<T>控制单一访问共享的内存</strong><br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::sync::Mutex;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> m <span style="color:#f92672">=</span> Mutex::new(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num <span style="color:#f92672">=</span> m.lock().unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>num <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;m = {:?}&#34;</span>, m); <span style="color:#75715e">//m = Mutex { data: 6, poisoned: false, .. }
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::sync::{Mutex, Arc};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::sync::thread;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> counter <span style="color:#f92672">=</span> Arc::new(Mutex::new(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> handles <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> counter <span style="color:#f92672">=</span> Arc::clone(<span style="color:#f92672">&amp;</span>counter);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> handle <span style="color:#f92672">=</span> thread::spawn(<span style="color:#f92672">||</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num <span style="color:#f92672">=</span> counter.lock().unwrap(); <span style="color:#75715e">//Mutex&lt;T&gt; provides interior mutability
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">*</span>num <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        handles.push(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> handle <span style="color:#66d9ef">in</span> handles {
</span></span><span style="display:flex;"><span>        handle.join().unwrap();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;counter:{}&#34;</span>, <span style="color:#f92672">*</span>counter.lock().unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/stable/std/sync/atomic/index.html" target="_blank" rel="noopener">std::sync::atomic</a> <br></p>
<h3 id="sync-send-trait">Sync, Send trait <a href="#sync-send-trait" class="anchor">🔗</a></h3><p>std::marker::Send trait<br> 实现了Send的类型的值的所有权可以在线程中转移。
大多rust中的类型都是Send的，也有例外，Rc<T></p>
<p>std::marker::Sync <br></p>
<p>标准库中提供的类型。</p>
<p>把rustc对并发安全的保证扩展到用户自定义的类型上。</p>
<h2 id="17-rust在面向对象编程上的特点">17 rust在面向对象编程上的特点 <a href="#17-rust%e5%9c%a8%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b%e4%b8%8a%e7%9a%84%e7%89%b9%e7%82%b9" class="anchor">🔗</a></h2><h2 id="18-模式和匹配-patterns-and-matching">18 模式和匹配 patterns and matching <a href="#18-%e6%a8%a1%e5%bc%8f%e5%92%8c%e5%8c%b9%e9%85%8d-patterns-and-matching" class="anchor">🔗</a></h2><h2 id="19-advance-features">19 advance features <a href="#19-advance-features" class="anchor">🔗</a></h2><ul>
<li>Unsafe Rust: static analysis is conservative.</li>
<li>Advanced traits:</li>
<li>Advanced types</li>
<li>Advanced functions and closures: function pointers and returning closures</li>
<li>Macros:</li>
</ul>
<h3 id="unsafe-rust">unsafe rust <a href="#unsafe-rust" class="anchor">🔗</a></h3><ul>
<li>解引用裸指针 *const T and *mut T</li>
<li>调用不安全的方法</li>
<li>todo</li>
</ul>
<h3 id="advance-trait">advance trait <a href="#advance-trait" class="anchor">🔗</a></h3><p>trait是用到定义共享的行为的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#![allow(unused)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">trait</span> Add<span style="color:#f92672">&lt;</span>Rhs<span style="color:#f92672">=</span>Self<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(self, rhs: <span style="color:#a6e22e">Rhs</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="advance-type">advance type <a href="#advance-type" class="anchor">🔗</a></h3><p>类型系统有两个基本的保障： 需要知道一个类型的所有值占多少空间。一个类型下的所有值占用相同的空间。<br>
str， dyn trait, slice 都是DST。不能直接使用这种类型。如果允许，let s1 str = &quot;aa&quot;; let s2 str = &quot;bbb&quot;;
那么str类型下的s1和s2占不同的空间，违背类型系统的保障。所有DST类型在语言中都是以引用的形式（智能指针）出现。
&amp;str -&gt; the address of the str and its length. <br></p>
<p>str -&gt; &amp;str, Box<str>, Rc<str>
trait -&gt; &amp;dyn Trait, Box<dyn Trait>, Rc<dyn Trait></p>
<h3 id="macros">Macros <a href="#macros" class="anchor">🔗</a></h3><h2 id="20-project-web-server">20 project: web server <a href="#20-project-web-server" class="anchor">🔗</a></h2><p>thread, Arc, Mutex, channel...</p>
<h2 id="其他附录">其他附录 <a href="#%e5%85%b6%e4%bb%96%e9%99%84%e5%bd%95" class="anchor">🔗</a></h2><h3 id="源码结构">源码结构 <a href="#%e6%ba%90%e7%a0%81%e7%bb%93%e6%9e%84" class="anchor">🔗</a></h3><p><p class="markdown-image">
  <img src="rust.svg" alt="image"  />
</p></p>
<h2 id="项目组织">项目组织 <a href="#%e9%a1%b9%e7%9b%ae%e7%bb%84%e7%bb%87" class="anchor">🔗</a></h2><h3 id="引入第三方依赖crate">引入第三方依赖crate <a href="#%e5%bc%95%e5%85%a5%e7%ac%ac%e4%b8%89%e6%96%b9%e4%be%9d%e8%b5%96crate" class="anchor">🔗</a></h3><p>例如在toml文件中引入rand crate后，cargo build的输出，Cargo.lock的内容。</p>
<h3 id="module">module <a href="#module" class="anchor">🔗</a></h3><p>package， crate， module。</p>
<p>模块机制: rust的mod即是命名空间。</p>
<p>use 是optional，可以使用full path 替换，不是必须使用的。</p>
<p>use作用：将其他module的item导入到current namespace，方便访问。
不带{}的mod作用：将module的内容插入到当前file中。</p>
<p>声明：mod 与 pub mod</p>
<p>引入：use 与 pub use</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> rand;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> rand::Rng; <span style="color:#75715e">// in order to use gen_range method in trait `Rng`.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// gen_range is a method in Rng trait.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// the basic idea is this: methods are defined on something called `trait`, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// and for the method to work, it needs the trait to be in scope.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> guess <span style="color:#f92672">=</span> rand::thread_rng().gen_range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">101</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;guess={}&#34;</span>, guess);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="工作空间-rust-workspace">工作空间 rust workspace <a href="#%e5%b7%a5%e4%bd%9c%e7%a9%ba%e9%97%b4-rust-workspace" class="anchor">🔗</a></h3><p><p class="markdown-image">
  <img src="mod_crate_workspace.svg" alt="image"  />
</p></p>
<hr>
<h2 id="数据">数据 <a href="#%e6%95%b0%e6%8d%ae" class="anchor">🔗</a></h2><h3 id="堆和栈">堆和栈 <a href="#%e5%a0%86%e5%92%8c%e6%a0%88" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>.to_string();
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;addr={:p}&#34;</span>, <span style="color:#f92672">&amp;</span>s);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出的地址是 栈中s = ptr|len|cap这个结构体的地址，还是ptr中堆上的地址？
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>; <span style="color:#75715e">// a is fatten pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a; <span style="color:#75715e">// copy trait, b is also a fatten pointer 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;&amp;a={:p}, &amp;b={:p}&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);  <span style="color:#75715e">// different addr on stack 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;*a={:p}, *b={:p}&#34;</span>, <span style="color:#f92672">&amp;*</span>a, <span style="color:#f92672">&amp;*</span>b); <span style="color:#75715e">// same addr which is on BSS segment
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> Data_Seg: <span style="color:#66d9ef">u32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span> () {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>.to_string();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;RODATA = {:p}&#34;</span>, <span style="color:#e6db74">&#34;hello world&#34;</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Data static var = {:p}&#34;</span>, <span style="color:#f92672">&amp;</span>Data_seg);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Text seg = {:p}&#34;</span>, foo <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> ());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// String的结构体分配在栈上，其引用指向栈地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;STACK (&amp;hello) = {:p}&#34;</span>, <span style="color:#f92672">&amp;</span>hello);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// hello持有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通过解引用获取堆上数据，然后取其引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;HEAP (&amp;*hello) = {:p}&#34;</span>, <span style="color:#f92672">&amp;*</span>hello);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Box实现了Pointer trait， 无需额外的解引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;HEAP box impl pointer, {:p}, {:p}&#34;</span>, data, <span style="color:#f92672">&amp;*</span>data);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="错误处理">错误处理 <a href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" class="anchor">🔗</a></h3><p>把错误封装在Result&lt;T, E&gt;中。
错误传播 ？。
unwrap()方法只关心成功的返回结果T，若出错，整个程序终止。</p>
<h3 id="迭代器-1">迭代器 <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8-1" class="anchor">🔗</a></h3><p>for循环可以用于任何实现了IntoIterator trait的数据结构。</p>
<h2 id="代码">代码 <a href="#%e4%bb%a3%e7%a0%81" class="anchor">🔗</a></h2><h3 id="函数与闭包">函数与闭包 <a href="#%e5%87%bd%e6%95%b0%e4%b8%8e%e9%97%ad%e5%8c%85" class="anchor">🔗</a></h3><h3 id="接口与虚表">接口与虚表 <a href="#%e6%8e%a5%e5%8f%a3%e4%b8%8e%e8%99%9a%e8%a1%a8" class="anchor">🔗</a></h3><p>虚表是每个trait有一份，还是每个对象有一份，还是每个胖指针有一份？</p>
<p>godbolt.org</p>
<p>impl TraitA for TypeB {}。 虚表是每个&lt;Trait, Type&gt;有一份，在编译时生成好在二进制文件里。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;byebye&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> traitObj1: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">dyn</span> Display <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> traitObj2: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">dyn</span> Debug <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> traitObj3: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">dyn</span> Display <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s2;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> traitObj4: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">dyn</span> Debug <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (addr1, vtable1) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span>{ transmute::<span style="color:#f92672">&lt;</span>_, (<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>)<span style="color:#f92672">&gt;</span>(traitObj1 <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">dyn</span> Display) };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (addr2, vtable2) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span>{ transmute::<span style="color:#f92672">&lt;</span>_, (<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>)<span style="color:#f92672">&gt;</span>(traitObj2 <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">dyn</span> Debug) };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (addr3, vtable3) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span>{ transmute::<span style="color:#f92672">&lt;</span>_, (<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>)<span style="color:#f92672">&gt;</span>(traitObj3 <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">dyn</span> Display) };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (addr4, vtable4) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span>{ transmute::<span style="color:#f92672">&lt;</span>_, (<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>)<span style="color:#f92672">&gt;</span>(traitObj4 <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">dyn</span> Debug) };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;s1:{:p}, s2: {:p}, main(): {:p}&#34;</span>, <span style="color:#f92672">&amp;</span>s1, <span style="color:#f92672">&amp;</span>s2, main <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;addr1: 0x{:x}, vtable1: 0x{:x}&#34;</span>, addr1, vtable1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>assert_eq!(addr1, addr2);
</span></span><span style="display:flex;"><span>assert_eq!(addr3, addr4);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// String + Display
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>assert_eq!(vtable1, vtable3);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// String + Debug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>assert_eq!(vtable2, vtable4);
</span></span></code></pre></div><h3 id="宏">宏 <a href="#%e5%ae%8f" class="anchor">🔗</a></h3><ul>
<li>声明宏</li>
<li>过程宏（函数宏 派生宏 属性宏）</li>
</ul>
<h1 id="expression--statement">expression 🆚 statement <a href="#expression--statement" class="anchor">🔗</a></h1><p>rust只有两种语句（无返回值），其他的均是表达式（有返回值）。
一种语句是表达式语句。在表达式后加；。一种语句是声明式语句。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> (ley y <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>); <span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// y = 6 is expression, return ().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> ( y <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>); <span style="color:#75715e">// x has the value `()`, not 6
</span></span></span></code></pre></div><hr>
<ul>
<li>所有权与借用， 生命周期</li>
<li>ownership, borrowing</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hallo&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> s1;
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;{},{}&#34;</span>, s1, s2); <span style="color:#75715e">// error[E0382]: borrow of moved value: `s1`.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hallo&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> s1.clone();  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        println!(<span style="color:#e6db74">&#34;{}, {}&#34;</span>, s1, s2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">//reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hallo&#34;</span>); <span style="color:#75715e">// s1 is the owner of data &#39;hallo&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;  <span style="color:#75715e">// s2 is a reference which points to the same data.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       println!(<span style="color:#e6db74">&#34;s1={}, s2={}&#34;</span>, s1, s2);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hallo&#34;</span>);
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1; 
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s2; <span style="color:#75715e">// two readonly reference of &#39;hallo&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       println!(<span style="color:#e6db74">&#34;s1={}, s2={}&#34;</span>, s1, s2);
</span></span><span style="display:flex;"><span>       println!(<span style="color:#e6db74">&#34;s3={}, len={}&#34;</span>, s3, s3.len());
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">//change string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>); <span style="color:#75715e">// mutable borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> s1;  <span style="color:#75715e">// mutable borrow occurs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       s2.push(<span style="color:#e6db74">&#39;~&#39;</span>);
</span></span><span style="display:flex;"><span>       println!(<span style="color:#e6db74">&#34;s2 = {}&#34;</span>, s2);  <span style="color:#75715e">// s2 = hello~
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#75715e">// can only use the original when the borrowed item is dropped.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#75715e">// s2 is dropped, so s1 can use.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       println!(<span style="color:#e6db74">&#34;s1 = {}&#34;</span>, s1);  <span style="color:#75715e">// s1 = hello~  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   }
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>); <span style="color:#75715e">// mutable borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> s1;  <span style="color:#75715e">// mutable borrow occurs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       s2.push(<span style="color:#e6db74">&#39;~&#39;</span>);
</span></span><span style="display:flex;"><span>       println!(<span style="color:#e6db74">&#34;s2 = {}&#34;</span>, s2); 
</span></span><span style="display:flex;"><span>       println!(<span style="color:#e6db74">&#34;s1 = {}&#34;</span>, s1); <span style="color:#75715e">// not compile!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       s2.push(<span style="color:#e6db74">&#39;~&#39;</span>) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>); <span style="color:#75715e">// mutable borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> s1;  <span style="color:#75715e">// mutable borrow occurs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       s2.push(<span style="color:#e6db74">&#39;~&#39;</span>);
</span></span><span style="display:flex;"><span>       println!(<span style="color:#e6db74">&#34;s1 = {}&#34;</span>, s1); <span style="color:#75715e">// not compile!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       println!(<span style="color:#e6db74">&#34;s2 = {}&#34;</span>, s2); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> words <span style="color:#f92672">=</span> vec![String::from(<span style="color:#e6db74">&#34;hallo&#34;</span>), String::from(<span style="color:#e6db74">&#34;español&#34;</span>), String::from(<span style="color:#e6db74">&#34;brett&#34;</span>)];
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, words);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> t <span style="color:#f92672">=</span> words[<span style="color:#ae81ff">1</span>].clone();
</span></span><span style="display:flex;"><span>        words[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> words[<span style="color:#ae81ff">2</span>].clone();
</span></span><span style="display:flex;"><span>        words[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, words);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// can&#39;t take two mutable loans from one vector,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// just cast them to raw pointers to do the swap.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        words.swap(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// built-in swap function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, words);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    std::mem::swap(..) // use unsafe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    pub fn swap(&amp;mut self, a: usize, b: usize) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        unsafe {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            let pa: *mut T = &amp;mut self[a];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            let pb: *mut T = &amp;mut self[b];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            ptr::swap(pa, pb);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="智能指针">智能指针 <a href="#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" class="anchor">🔗</a></h3><p>Deref trait,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Deref {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Target</span>: <span style="color:#f92672">?</span>Sized;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::Target;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Drop trait</p>
<h3 id="动态分派静态分派">动态分派，静态分派 <a href="#%e5%8a%a8%e6%80%81%e5%88%86%e6%b4%be%e9%9d%99%e6%80%81%e5%88%86%e6%b4%be" class="anchor">🔗</a></h3><p>静态分派： 靠泛型的单态化实现，编译时确定函数调用。 callee确定，可以inline。
动态分派：靠trait object实现，运行时确定函数调用。</p>
<p>trait类型是DST类型， 在编译时无法确定size。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Fly {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fly</span>(<span style="color:#f92672">&amp;</span>self);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Fly是trait类型，在编译时无法确定size，无法直接作为param 和return。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 和java，golang的interface有区别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>(arg: <span style="color:#a6e22e">Fly</span>){} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 利用泛型约束T， ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Fly</span><span style="color:#f92672">&gt;</span>(arg: <span style="color:#a6e22e">T</span>) {}
</span></span></code></pre></div><p>trait类型是DST， 实现trait的具体类型可能有多个，指向trait类型的指针（胖）需要记录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::raw <span style="color:#75715e">// module
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TraitObject</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> data: <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span>(),   <span style="color:#75715e">// 实现trait的具体对象，对象里不包含指向虚函数table的指针。与C++不同。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">pub</span> vtable: <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span>(), <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::mem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Bird</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Duck</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Fly <span style="color:#66d9ef">for</span> Bird {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fly</span>(<span style="color:#f92672">&amp;</span>self) {println!(<span style="color:#e6db74">&#34;bird can fly&#34;</span>);}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Fly <span style="color:#66d9ef">for</span> Duck {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fly</span>(<span style="color:#f92672">&amp;</span>self) {println!(<span style="color:#e6db74">&#34;duck can fly&#34;</span>);}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &amp;Fly, Box&lt;Fly&gt; both trait object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_trait_object</span>(p: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Fly</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (data, vtalbe): (<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span>{mem::transmute(p)};
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;trait object: data={}, vtable={}&#34;</span>, data, vtable);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> v: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> vtable <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span>() <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;vtable {}, {}, {}, {}&#34;</span>, <span style="color:#f92672">*</span>v, <span style="color:#f92672">*</span>v.offset(<span style="color:#ae81ff">1</span>), <span style="color:#f92672">*</span>v.offset(<span style="color:#ae81ff">2</span>), <span style="color:#f92672">*</span>v.offset(<span style="color:#ae81ff">3</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duck Duck;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p_duck <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>duck;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p_fly <span style="color:#f92672">=</span> p_duck <span style="color:#66d9ef">as</span> <span style="color:#f92672">&amp;</span>Fly;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    let p_fly = TraitObject{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            data: &amp;p_duck, // store data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            vtable: &amp;Fly_for_Duck_vtable, //store method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    p_fly.fly();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        (p_fly.vtable.method)(p_fly.data);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;size of p_duck={}, size of p_fly={}&#34;</span>, mem::size_of_val(p_duck), mem::size_of_val(p_fly));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duck_fly: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span>{mem::transmute(Duck::fly)};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bird_fly: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span>{mem::transmute(Bird::fly)};
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Duck::fly={}, Bird::fly={}&#34;</span>, duck_fly, bird_fly);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print_trait_object(p_fly);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bird Bird;
</span></span><span style="display:flex;"><span>    print_trait_object(<span style="color:#f92672">&amp;</span>brid <span style="color:#66d9ef">as</span> <span style="color:#f92672">&amp;</span>Fly);
</span></span><span style="display:flex;"><span>}x
</span></span></code></pre></div><p>object safe： trait object受到限制。</p>
<ul>
<li>当trait上有Self：sized限制时，无法构造trait obj。</li>
<li>trait里所有函数都是object safe
<ul>
<li>当trait里函数上有Self: sized限制时，该函数不会加入到vtable中。</li>
<li>当函数中除了self参数之外还有Self类型作为参数或者返回类型时，</li>
<li>当函数有泛型参数时。</li>
</ul>
</li>
</ul>
<h3 id="closure">closure <a href="#closure" class="anchor">🔗</a></h3><p>如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包。<br>
闭包相当于一个捕获变量的结构体，实现了 FnOnce 或 FnMut 或 Fn。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">f</span><span style="color:#f92672">&lt;</span>F: FnOnce() -&gt; String<span style="color:#f92672">&gt;</span>(g: <span style="color:#a6e22e">F</span>) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;{}&#34;</span>, g());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;halo&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> t <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f(<span style="color:#f92672">||</span>{
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> <span style="color:#f92672">&amp;</span>t;
</span></span><span style="display:flex;"><span>    s
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Closure</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>    s: String,
</span></span><span style="display:flex;"><span>    t: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> String,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> <span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> FnOnce<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Closure<span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> String;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">call_once</span>(self) -&gt; <span style="color:#a6e22e">Output</span>{
</span></span><span style="display:flex;"><span>        self.s <span style="color:#f92672">+=</span> <span style="color:#f92672">&amp;*</span>self.t;
</span></span><span style="display:flex;"><span>        self.s
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f(Closure{s: <span style="color:#a6e22e">s</span>, t: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">t</span>});
</span></span></code></pre></div><p>标准库中： Rc, Box::leak() 突破单一所有权<br>
Iterator 不断构造新结构，支持lazy evaluation<br>
Rc::clone 内部可变性。</p>
<p>tree src, readme.md 目录框架<br></p>
<p>dors.rs &lt;-&gt; code 方便来回切换 <br></p>
<p>从trait开始： docs上required method(需要被实现的方法), provided method, implementations on foreign types， implementor。</p>
<p>从struct开始： methods， trait implementation, auto trait, blanket trait <br></p>
<p>[Blanket Implementations}(https://doc.rust-lang.org/nightly/src/core/any.rs.html#200)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[stable(feature = </span><span style="color:#e6db74">&#34;rust1&#34;</span><span style="color:#75715e">, since = </span><span style="color:#e6db74">&#34;1.0.0&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">&#39;</span>static <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized<span style="color:#f92672">&gt;</span> Any <span style="color:#66d9ef">for</span> T {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">type_id</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">TypeId</span> {
</span></span><span style="display:flex;"><span>        TypeId::of::<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>  <code>T: 'static</code> -&gt;  the type does not contain any non-static references。 <br>
  T类型是要么拥有所有权，要么是拥有静态引用&amp;str。 <br></p>
<p>blanket trait例如Any， 为泛型T实现了Any trait， 那么任何类型只要满足bound trait</p>
<p><a href="https://blog.rust-lang.org/2015/04/17/Enums-match-mutation-and-moves.html" target="_blank" rel="noopener">match is designed to work quite well without taking ownership</a><br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tree_weight_v2</span>(t: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">BinaryTree</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//               ^~~~~~~~~~~ The `&amp;` means we are *borrowing* the tree
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// *t == L-value expression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">match</span> <span style="color:#f92672">*</span>t { <span style="color:#75715e">// *t ==  not making a copy of the tree, nor moving it to a new temporary location
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        BinaryTree::Leaf(payload) <span style="color:#f92672">=&gt;</span> payload,
</span></span><span style="display:flex;"><span>        BinaryTree::Node(<span style="color:#66d9ef">ref</span> left, payload, <span style="color:#66d9ef">ref</span> right) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            tree_weight_v2(left) <span style="color:#f92672">+</span> payload <span style="color:#f92672">+</span> tree_weight_v2(right)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 当所有权转移时，数据的可变性可能发生改变。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> immutable_box <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">5</span><span style="color:#66d9ef">u32</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;immutable_box contains {}&#34;</span>, immutable_box);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//*immutable_box = 4;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 移动box，改变所有权（和可变性）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> mutable_box <span style="color:#f92672">=</span> immutable_box;
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;mutable_box contains {}&#34;</span>, mutable_box);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>mutable_box <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;mutable_box now contains {}&#34;</span>, mutable_box);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 部分移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>        name: String,
</span></span><span style="display:flex;"><span>        age: <span style="color:#66d9ef">u8</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> person <span style="color:#f92672">=</span> Person {
</span></span><span style="display:flex;"><span>        name: String::from(<span style="color:#e6db74">&#34;brett&#34;</span>),
</span></span><span style="display:flex;"><span>        age: <span style="color:#ae81ff">19</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `name` 从 person 中移走，但 `age` 只是引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> Person { name, <span style="color:#66d9ef">ref</span> age } <span style="color:#f92672">=</span> person;
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;The person&#39;s age is {}&#34;</span>, age);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;The person&#39;s name is {}&#34;</span>, name);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 报错！部分移动值的借用：`person` 部分借用产生
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//println!(&#34;The person struct is {:?}&#34;, person);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// `person` 不能使用，但 `person.age` 因为没有被移动而可以继续使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;The person&#39;s age from person struct is {}&#34;</span>, person.age);
</span></span></code></pre></div><br>
<p>直接访问Vec结构体中的len字段，可以吗？ 分两种情况吧，<a href="https://doc.rust-lang.org/beta/error_codes/E0616.html" target="_blank" rel="noopener">safe rust不行</a>。 unsafe rust下 mem::transmute 应该是可以的。
error[E0616]: field <code>len</code> of struct <code>Vec</code> is private
<a href="https://doc.rust-lang.org/beta/error_codes/E0616.html" target="_blank" rel="noopener">https://doc.rust-lang.org/beta/error_codes/E0616.html</a></p>
<pre tabindex="0"><code>&#34;a&#34;.to_string() vs &#34;a&#34;.to_owned() 
https://users.rust-lang.org/t/to-string-vs-to-owned-for-string-literals/1441
</code></pre><p>How to step into std source code when debugging in VS Code?`
<a href="https://users.rust-lang.org/t/solved-how-to-step-into-std-source-code-when-debugging-in-vs-code/25319" target="_blank" rel="noopener">solved</a> <br>
<a href="https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#source-path-remapping" target="_blank" rel="noopener">Source Path Remapping</a><br></p>
<h1 id="格式化输出">格式化输出 <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba" class="anchor">🔗</a></h1><p><code>{}</code> 适用于 实现了 <code>std::fmt::Display</code>类型。 <code>{:?}</code> 适用于 实现了<code>std::fmt::Debug</code>类型</p>
<h1 id="rust书写的习惯">rust书写的习惯 <a href="#rust%e4%b9%a6%e5%86%99%e7%9a%84%e4%b9%a0%e6%83%af" class="anchor">🔗</a></h1><p>类型是驼峰命名。 变量名和函数名是蛇形命名。</p>
<h2 id="参考与资料">参考与资料 <a href="#%e5%8f%82%e8%80%83%e4%b8%8e%e8%b5%84%e6%96%99" class="anchor">🔗</a></h2><p>[1]<a href="https://www.ralfj.de/projects/rust-101/main.html" target="_blank" rel="noopener"> welcome to rust 101</a><br>
[2]<a href="https://tourofrust.com/" target="_blank" rel="noopener"> rust by example</a><br>
[3]<a href="https://blog.rust-lang.org/" target="_blank" rel="noopener"> rust blog</a><br>
[4]<a href="https://this-week-in-rust.org/" target="_blank" rel="noopener"> this week in rust</a><br>
[5]<a href="https://blog.rust-lang.org/inside-rust/index.html" target="_blank" rel="noopener"> inside rust</a><br>
[6]<a href="https://tourofrust.com/TOC_en.html" target="_blank" rel="noopener"> Tour of Rust</a> 以简单的例子串讲，很好入手<br>
[7]<a href="https://doc.rust-lang.org/stable/book/" target="_blank" rel="noopener">《The Rust Programming Language》</a> done<br>
[8]<a href="https://rust-book.cs.brown.edu/experiment-intro.html" target="_blank" rel="noopener">《Rust Book experiment: Experiment Introduction》</a>
[9]<a href="https://doc.rust-lang.org/nightly/nomicon/dot-operator.html" target="_blank" rel="noopener"> rust noniom</a><br>
[10]<a href="https://cheats.rs/#data-structures" target="_blank" rel="noopener"> Rust Language Cheat Sheet</a> 适合快速浏览，有问题时查看的工具书 done<br>
[11]<a href="https://doc.rust-lang.org/nightly/rust-by-example" target="_blank" rel="noopener"> rust by example</a> 每篇都很短并配有例子，很好入手。done<br>
[12]<a href="https://github.com/google/comprehensive-rust" target="_blank" rel="noopener"> google comprehensive-rust 4days</a><br>
[13]<a href="github.com/rust-in-blockchain/awesome-blockchain-rust"> awesome block chain rust</a><br>
[14]<a href=""></a><br>
[15]<a href=""></a><br>
[16]<a href=""></a><br>
[17]<a href=""></a><br>
[18]<a href=""></a><br>
[19]<a href=""></a><br>
[20]<a href=""></a><br>
text editor. <a href="https://www.philippflenker.com/hecto" target="_blank" rel="noopener">https://www.philippflenker.com/hecto</a>
pngme book.  build your text editor with rust.</p>
<pre><code>                    writing an os in rust.   os.phil-opp.com/zh-CN/     github.com/phil-opp/blog-os
</code></pre>

    </div>

    
        <div class="tags">
            
                <a href="http://brettkk.github.io/tags/rust">rust</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <script src="https://utteranc.es/client.js"
repo="brettKK/brettkk.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>  

    <div class="copyright">
    
       © Copyright 
       2023 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-cactus-plus'>nodejh</a>
      </div>
    
</footer>




  </body>
</html>
