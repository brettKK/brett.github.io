<!DOCTYPE html>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<html lang="zh-cn">
  <head>
    <title>环境问题 &#43; 类型系统疑问 | brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="在vscode下配置rust项目的阅读和debug 🔗rust">
<meta name="generator" content="Hugo 0.103.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/zenburn.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" href="http://brettkk.github.io/css/syntax.css" />


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">环境问题 &#43; 类型系统疑问</h1>

    <div class="tip">
        <time datetime="2022-11-21 11:33:56 &#43;0800 CST">Nov 21, 2022</time>
        <span class="split">
          ·
        </span>
        <span>
          5027 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          11 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#在vscode下配置rust项目的阅读和debug">在vscode下配置rust项目的阅读和debug</a></li>
    <li><a href="#stdoptionoption的疑问">std::option::Option的疑问</a></li>
    <li><a href="#语言中的sugar">语言中的sugar</a>
      <ul>
        <li><a href="#coercion">coercion</a></li>
        <li><a href="#deref">deref</a></li>
      </ul>
    </li>
    <li><a href="#borrow-and-asref">Borrow and AsRef</a></li>
    <li><a href="#trait的关联类型">trait的关联类型</a></li>
    <li><a href="#所有权转移时可改数据的可变属性部分移动">所有权转移时可改数据的可变属性，部分移动</a></li>
    <li><a href="#ref">ref</a></li>
    <li><a href="#static">'static</a></li>
    <li><a href="#迭代器中的类型疑问">迭代器中的类型疑问</a></li>
    <li><a href="#as-_">as _</a></li>
    <li><a href="#intoiterator">IntoIterator</a></li>
    <li><a href="#智能指针">智能指针</a></li>
    <li><a href="#pint-unpin">Pin<T>, Unpin</a></li>
    <li><a href="#send-sync">Send, Sync</a></li>
    <li><a href="#类型占用了多少内存">类型占用了多少内存</a>
      <ul>
        <li><a href="#dst">DST</a></li>
      </ul>
    </li>
    <li><a href="#错误处理">错误处理</a></li>
    <li><a href="#lifetime">lifetime</a></li>
    <li><a href="#unsafe">unsafe</a></li>
    <li><a href="#泛型">泛型</a></li>
    <li><a href="#写算法需要熟练掌握的模块">写算法需要熟练掌握的模块</a>
      <ul>
        <li><a href="#optiont-会用到的api">Option<T> 会用到的API</a></li>
        <li><a href="#asreft">AsRef<T></a></li>
      </ul>
    </li>
    <li><a href="#stdsyncatmoic-memory-ordering">std::sync::atmoic, memory ordering</a></li>
    <li><a href="#包模块可见性">包，模块，可见性</a></li>
    <li><a href="#stdcmd包">std::cmd包</a></li>
    <li><a href="#泛型编程">泛型编程</a></li>
    <li><a href="#语法问题">语法问题</a></li>
    <li><a href="#类型的嵌套">类型的嵌套</a></li>
    <li><a href="#对象安全-trait-object">对象安全， trait object</a></li>
    <li><a href="#any-trait"><code>Any</code> trait</a></li>
    <li><a href="#fn-fnmut-fnonce-区别">Fn FnMut FnOnce 区别</a></li>
    <li><a href="#所有权move语义借用生命周期的推进关系">所有权，move语义，借用，生命周期的推进关系</a></li>
    <li><a href="#traits的内存表示">traits的内存表示</a></li>
    <li><a href="#attribute-属性">attribute 属性</a></li>
    <li><a href="#rust-生命宏-过程宏-rust中的插桩">rust 生命宏， 过程宏， rust中的插桩</a></li>
    <li><a href="#子类型-类型产生器-协变逆变不变">子类型， 类型产生器， 协变，逆变，不变</a></li>
    <li><a href="#t-mut-t">&amp;T &amp;mut T</a></li>
    <li><a href="#rust-内存模型">rust 内存模型</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <h1 id="在vscode下配置rust项目的阅读和debug">在vscode下配置rust项目的阅读和debug <a href="#%e5%9c%a8vscode%e4%b8%8b%e9%85%8d%e7%bd%aerust%e9%a1%b9%e7%9b%ae%e7%9a%84%e9%98%85%e8%af%bb%e5%92%8cdebug" class="anchor">🔗</a></h1><pre tabindex="0"><code>rust-analyzer failed to load workspace: Failed to read Cargo metadata from Cargo.toml file /Users/gonglei/rust-workspace/rust/Cargo.toml, cargo 1.53.0 (4369396ce 2021-04-27): Failed to run `&#34;cargo&#34; &#34;metadata&#34; &#34;--format-version&#34; &#34;1&#34; &#34;--manifest-path&#34; &#34;/Users/gonglei/rust-workspace/rust/Cargo.toml&#34; &#34;--filter-platform&#34; &#34;aarch64-apple-darwin&#34;`: `cargo metadata` exited with an error: error: failed to load manifest for workspace member `/Users/gonglei/rust-workspace/rust/src/bootstrap` Caused by: failed to parse manifest at `/Users/gonglei/rust-workspace/rust/src/bootstrap/Cargo.toml` Caused by: feature `edition2021` is required this Cargo does not support nightly features, but if you switch to nightly channel you can add `cargo-features = [&#34;edition2021&#34;]` to enable this feature


solved：Update the Rust to satisfy the new edition 2021.
rustup default nightly &amp;&amp; rustup update
</code></pre><hr>
<p>阅读rust-lang时遇到的问题， 原因是git大仓下有些submodule, 这些submodule在clone时并不会随大仓一起下载到本地。<br></p>
<p>rustc -g main.rs<br>
lldb main<br>
b main
run
step
then...</p>
<pre tabindex="0"><code>* thread #1, name = &#39;main&#39;, queue = &#39;com.apple.main-thread&#39;, stop reason = step in
</code></pre><pre tabindex="0"><code>rust-analyzer failed to load workspace: Failed to read Cargo metadata from Cargo.toml file /Users/gonglei/rust-1.65.0/Cargo.toml, Some(Version { major: 1, minor: 67, patch: 0, pre: Prerelease(&#34;nightly&#34;) }): Failed to run `&#34;cargo&#34; &#34;metadata&#34; &#34;--format-version&#34; &#34;1&#34; &#34;--manifest-path&#34; &#34;/Users/gonglei/rust-1.65.0/Cargo.toml&#34; &#34;--filter-platform&#34; &#34;aarch64-apple-darwin&#34;`: `cargo metadata` exited with an error: error: failed to load manifest for workspace member `/Users/gonglei/rust-1.65.0/src/tools/rust-installer` Caused by: failed to read `/Users/gonglei/rust-1.65.0/src/tools/rust-installer/Cargo.toml` Caused by: No such file or directory (os error 2)
</code></pre><p><strong>遇到调用库函数时进入到汇编，找不到源代码时的配置</strong></p>
<pre tabindex="0"><code>//settings.json
{
    &#34;lldb.executable&#34;: &#34;rust-lldb&#34;,
    &#34;lldb.launch.sourceLanguages&#34;: [&#34;rust&#34;],
    &#34;lldb.launch.sourceMap&#34;: {
      &#34;/rustc/e75aab045fc476f176a58c408f6b06f0e275c6e1/&#34;: &#34;/Users/brett/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust&#34;
    },
}
</code></pre><p>增加配置后，rust/library里的core, std, alloc都可以step in进去了。 但是compile相关的代码还是step in到了汇编<br>
rustup安装完后
<img src="/rust/rustup_copy_compile.png" height = "400" /><br>
复制后， lldb debug step into compiler了。<br>
<img src="/rust/rust_step_in_compiler.png" width = "605" /><br></p>
<hr>
<h1 id="stdoptionoption的疑问">std::option::Option的疑问 <a href="#stdoptionoption%e7%9a%84%e7%96%91%e9%97%ae" class="anchor">🔗</a></h1><p>std::option::Option的map方法消耗所有权且返回<code>Option&lt;U&gt;</code>类型， 与迭代器中的map方法同名，但是返回值不相同。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maybe_some_string <span style="color:#f92672">=</span> Some(String::from(<span style="color:#e6db74">&#34;Hello, World!&#34;</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maybe_some_len <span style="color:#f92672">=</span> maybe_some_string.map(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s.len());
</span></span><span style="display:flex;"><span>assert_eq!(maybe_some_len, Some(<span style="color:#ae81ff">13</span>));
</span></span></code></pre></div><p>ok_or()方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Option<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>              <span style="color:#f92672">^^^^^^^^^^^^^^^^^^^^^^^^^^^</span> <span style="color:#960050;background-color:#1e0010">`</span>main<span style="color:#960050;background-color:#1e0010">`</span> can only <span style="color:#66d9ef">return</span> types that implement <span style="color:#960050;background-color:#1e0010">`</span>Termination<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">=</span> help: <span style="color:#a6e22e">consider</span> using <span style="color:#960050;background-color:#1e0010">`</span>()<span style="color:#960050;background-color:#1e0010">`</span>, or a <span style="color:#960050;background-color:#1e0010">`</span>Result<span style="color:#960050;background-color:#1e0010">`</span>
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/std/process/trait.Termination.html" target="_blank" rel="noopener">main函数的return type必须实现std::process::Termination特征</a><br>，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> Infallible
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> <span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> ()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> ExitCode
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Termination</span>, E: <span style="color:#a6e22e">Debug</span><span style="color:#f92672">&gt;</span> Termination <span style="color:#66d9ef">for</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h1 id="语言中的sugar">语言中的sugar <a href="#%e8%af%ad%e8%a8%80%e4%b8%ad%e7%9a%84sugar" class="anchor">🔗</a></h1><h2 id="coercion">coercion <a href="#coercion" class="anchor">🔗</a></h2><p>弱化类型去匹配方法的签名。 &amp;mut T to &amp;T。<br></p>
<p><code>.</code>操作符的背后（编译器）做了很多操作<br>
auto-referencing, auto-dereferencing, and coercion until types match. copy由编译器来修改的地方会让人产生疑惑<br></p>
<p><a href="https://rustc-dev-guide.rust-lang.org/method-lookup.html" target="_blank" rel="noopener">编译器的type checking</a><br></p>
<p>Method Resolution: Derefs or borrow x until x.f() works. <br></p>
<p>有两种coercion： <code>auto_ref</code>, <code>auto_deref</code></p>
<ul>
<li>auto_ref,  T -&gt; &amp;T, mut T -&gt; &amp;mut T (单纯的想要引用T)
<ul>
<li>object.something(), rustc 可以添加&amp;object， &amp;mut object, *object来是caller的类型与something的签名匹配。</li>
</ul>
</li>
<li>auto_deref, 自动调用Deref::deref (Defref描述了外部类型转为内部类型，一般用于智能指针）
<ul>
<li>Option<T> 没有实现Deref。</li>
<li>String<T> 实现了Deref。</li>
<li>Box<T> 实现了Deref。  &amp;*x: 意思是 &quot;reborrow&quot;
<ul>
<li>a = Box::new(&quot;hallo&quot;.to_owned());</li>
<li>let b = *a</li>
<li>let b = *(Box::defref(&amp;a))</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a: Box<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Box::new(<span style="color:#e6db74">&#34;hello&#34;</span>.to_owned());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b: <span style="color:#66d9ef">&amp;</span>String <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;*</span>a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> c: <span style="color:#66d9ef">&amp;</span>String <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>(std::ops::Deref::deref(<span style="color:#f92672">&amp;</span>a)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>Box::new(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    test(<span style="color:#f92672">&amp;**</span>a); <span style="color:#75715e">// one * to dereference the Box, get &amp;i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// one * to dereference the &amp;， get i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// reborrow with &amp;, get &amp;i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>(a: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i32</span>) { println!(<span style="color:#e6db74">&#34;{}&#34;</span>, <span style="color:#f92672">*</span>a) }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyI32</span>(<span style="color:#66d9ef">i32</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> MyI32 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_string</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;&amp;self={:?}&#34;</span>, self); <span style="color:#75715e">// auto add *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        println!(<span style="color:#e6db74">&#34;*self={:?}&#34;</span>, <span style="color:#f92672">*</span>self);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_my_i32</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mi32 <span style="color:#f92672">=</span> MyI32(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    mi32.print_string();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> box_my_i32 <span style="color:#f92672">=</span> Box::new(mi32);
</span></span><span style="display:flex;"><span>    box_my_i32.print_string(); <span style="color:#75715e">// Box&lt;MyI32&gt; -&gt; &amp;MyI32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">&amp;</span>box_my_i32).print_string();
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>box_my_i32).print_string();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 多了一个&amp; ，compile自动去掉来match类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">&amp;*</span>box_my_i32).print_string();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Option<String> -- Not coercion --&gt;  Option&lt;&amp;str&gt; <br></p>
<h2 id="deref">deref <a href="#deref" class="anchor">🔗</a></h2><p>解引用类型去匹配方法。</p>
<h1 id="borrow-and-asref">Borrow and AsRef <a href="#borrow-and-asref" class="anchor">🔗</a></h1><p>&amp; == ampersand == ref <br></p>
<p>很相近，但不同<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> AsRef<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: <span style="color:#f92672">?</span>Sized,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_ref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>&amp;</code>借用（引用）是blanket implement，所有类型都实现了<br>
<code>Borrow</code> <br>
<code>AsRef</code>是做类型转换了。 定制化 <code>as_ref</code> 后的类型, 可能self不同的另外一种（String -&gt; &amp;str）, 可能是self结构下的某一个字段的引用。<br></p>
<ul>
<li>对值类型的转换 <code>From&lt;T&gt;</code>, <code>Into&lt;T&gt;</code></li>
<li>对引用类型的转换 <code>AsRef&lt;T&gt;</code>, <code>AsMut&lt;T&gt;</code></li>
</ul>
<h1 id="trait的关联类型">trait的关联类型 <a href="#trait%e7%9a%84%e5%85%b3%e8%81%94%e7%b1%bb%e5%9e%8b" class="anchor">🔗</a></h1><p><strong>为什么需要关联类型？</strong><br>
使用上不方便的地方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">container</span>(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Contains<span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">contains</span>(<span style="color:#f92672">&amp;</span>self, _: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">A</span>, _: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">B</span>) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">first</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span>; <span style="color:#75715e">// 并不显示需要A，B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">last</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span>;  <span style="color:#75715e">// 并不显示需要A，B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 用到Contains做trait bound时需要携带A， B ，不方便。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">difference</span><span style="color:#f92672">&lt;</span>A, B, C<span style="color:#f92672">&gt;</span>(container: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">C</span>) -&gt; <span style="color:#66d9ef">i32</span> <span style="color:#a6e22e">where</span>
</span></span><span style="display:flex;"><span>    C: <span style="color:#a6e22e">Contains</span><span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    container.last() <span style="color:#f92672">-</span> container.first()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//vs 关联类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">trait</span> Contains {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span>; <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">B</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">contains</span>(<span style="color:#f92672">&amp;</span>self, _: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::A, _: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::B) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用起来不用带泛型A，B，方便一点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">difference</span><span style="color:#f92672">&lt;</span>C: <span style="color:#a6e22e">Contains</span><span style="color:#f92672">&gt;</span>(container: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">C</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>      container.last() <span style="color:#f92672">-</span> container.first();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="所有权转移时可改数据的可变属性部分移动">所有权转移时可改数据的可变属性，部分移动 <a href="#%e6%89%80%e6%9c%89%e6%9d%83%e8%bd%ac%e7%a7%bb%e6%97%b6%e5%8f%af%e6%94%b9%e6%95%b0%e6%8d%ae%e7%9a%84%e5%8f%af%e5%8f%98%e5%b1%9e%e6%80%a7%e9%83%a8%e5%88%86%e7%a7%bb%e5%8a%a8" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> immutable_box <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> mutable_box <span style="color:#f92672">=</span> immutable_box;
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>mutable_box <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span></code></pre></div><p>结构体中的field可以部分移动到外部。</p>
<h1 id="ref">ref <a href="#ref" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">ref</span> ref_x1 <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ref_x2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x; <span style="color:#75715e">// ref_x1, ref_x2 same
</span></span></span></code></pre></div><h1 id="static">'static <a href="#static" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Trait bound
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// T  type does not contain any non-static references
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">generic</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">&#39;</span>static <span style="color:#f92672">+</span> <span style="color:#66d9ef">impl</span> Debug<span style="color:#f92672">&gt;</span>(x: <span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>  println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>genric(i); <span style="color:#75715e">//✅
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>genric(<span style="color:#f92672">&amp;</span>i) <span style="color:#75715e">//❌
</span></span></span></code></pre></div><h1 id="迭代器中的类型疑问">迭代器中的类型疑问 <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e4%b8%ad%e7%9a%84%e7%b1%bb%e5%9e%8b%e7%96%91%e9%97%ae" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vec1 <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vec2 <span style="color:#f92672">=</span> vec2[<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 对 vec1 的 `iter()` 举出 `&amp;i32`, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `find` 方法会把迭代器元素的引用传给闭包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 传给闭包的类型是&amp;&amp;i32 用&amp;&amp;x解构， x 类型为i32。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;find 2 in vec1: {:?}&#34;</span>, vec1.iter().find(<span style="color:#f92672">|&amp;&amp;</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;find 2 in vec2: {:?}&#34;</span>, vec2.iter().find(<span style="color:#f92672">|&amp;</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>));
</span></span></code></pre></div><h1 id="as-_">as _ <a href="#as-_" class="anchor">🔗</a></h1><h1 id="intoiterator">IntoIterator <a href="#intoiterator" class="anchor">🔗</a></h1><h1 id="智能指针">智能指针 <a href="#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" class="anchor">🔗</a></h1><p>在指针的基础上，附加元数据+功能<br></p>
<p>在rust中trait决定了类型的行为， 智能指针的行为涉及到<code>Deref trait</code> , <code>Drop trait</code>, 拥有指针语义，拥有内存自动管理。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Deref {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Target</span>: <span style="color:#f92672">?</span>size;
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">/// Dereference the value 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>  <span style="color:#e6db74">/// *X =》 *(X.deref())
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::Target;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Box</code></p>
<p><code>Vec&lt;T&gt;, String</code></p>
<p><code>Rc, Arc</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RcBox</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  strong: <span style="color:#a6e22e">Cell</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>  weak: <span style="color:#a6e22e">Cell</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>  value: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArcInner</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  strong: <span style="color:#a6e22e">atomic</span>::AtmoicUsize,
</span></span><span style="display:flex;"><span>  weak: <span style="color:#a6e22e">atmoic</span>::AtomicUsize,
</span></span><span style="display:flex;"><span>  data: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Cell, RefCell</code> 内部可变性<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"></code></pre></div><p><code>Mutex, RwLock</code></p>
<p><code>Rc&lt;RefCell&lt;T&gt;&gt;</code>  一个RefCell<T> 可以有多个所有者。
<code>RefCell&lt;Rc&lt;T&gt;&gt;</code> <br></p>
<p>Cell， RefCell在功能上没有区别。<br>
Cell<T> 使用于 T实现了Copy的情况<br>
RefCell<T> 内部可变， 一个borrow_mut修改后，其他引用可以看到修改。 <br></p>
<p>Rc --downgrade() --&gt; Weak <br>
Weak -- Upgrade() --&gt; Option<Rc> <br></p>
<p>Box<T> -&gt; Unqiue<T> -&gt; NonNull<T> --&gt; *const T, *mut T <br></p>
<h1 id="pint-unpin">Pin<T>, Unpin <a href="#pint-unpin" class="anchor">🔗</a></h1><p>很多情况下，其实Pin是用不到的。因为大多数情形下，都实现Unpin Traits。<br>
在引入的async/await编程中, Futrue的移动, 如果结构体包含了自引用， 当对象发生移动时引用的指针会失效，所以需要Pin住<br>
Pin对象的手段： 禁止获取<code>&amp;mut T</code>.</p>
<p><code>Pin&lt;P&gt;</code>, 包裹的p（必须是实现<code>Deref trait</code>的对象）是指针指向原始类型T， 理解为 <code>Pin&lt;P&lt;T&gt;&gt;</code> <br>
给定 <code>Pin&lt;P&lt;T&gt;&gt;</code>类型的数据，只要 <code>T</code> 不满足 <code>Unpin trait</code>，则 <code>Safe Rust</code> 下无法获得 <code>&amp;mut T</code>和 <code>T</code>，从而让 <code>T</code> 不能被 <code>move</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Example</span> {
</span></span><span style="display:flex;"><span>    data: String,
</span></span><span style="display:flex;"><span>    ptr: <span style="color:#a6e22e">NonNull</span><span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">Deref</span><span style="color:#f92672">&lt;</span>Target: Unpin<span style="color:#f92672">&gt;&gt;</span> Pin<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(pointer: <span style="color:#a6e22e">P</span>) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="send-sync">Send, Sync <a href="#send-sync" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> RwLock<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> RwLock<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Mutex<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> Mutex<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: Send<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Sender<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">!</span>Sync <span style="color:#66d9ef">for</span> Sender<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// T: Send + Sync， 才为Arc实现Send。所以Arc&lt;RefCell&gt; 不能在线程spawn时使用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span> T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span> T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized
</span></span></code></pre></div><p>Arc::new(RwLock::new(mpsc::Sender<T>))</p>
<p>Sender<T> no sync -&gt; RwLock no sync -&gt; Arc is not send and not sync.</p>
<p>Sender<T> is &quot;thread safe&quot; in that it can be sent between threads, but it cannot be shared between threads.  <br></p>
<ul>
<li>Send + Sync -&gt; 大多数类型都是的</li>
<li>！Send + Sync -&gt;</li>
<li>！Send + ! Sync -&gt;  Rc， Raw pointer， Arc<T> where T: Send + sync</li>
<li>Send + !Sync -&gt;  内部可变的UnsafeCell, mpsc::Sender, Cell, RefCell</li>
</ul>
<h1 id="类型占用了多少内存">类型占用了多少内存 <a href="#%e7%b1%bb%e5%9e%8b%e5%8d%a0%e7%94%a8%e4%ba%86%e5%a4%9a%e5%b0%91%e5%86%85%e5%ad%98" class="anchor">🔗</a></h1><p><a href="https://play.rust-lang.org/?gist=41ac3acde9ea070db48add40d5d12831&amp;version=nightly" target="_blank" rel="noopener">NonNull</a></p>
<p>rustc raii.rs &amp;&amp; valgrind ./raii</p>
<h2 id="dst">DST <a href="#dst" class="anchor">🔗</a></h2><p>&amp;dyn Trait -&gt; (*mut data, *mut vtable) <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Oper {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sub</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FatPointer</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  data: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">mut</span> Data,
</span></span><span style="display:flex;"><span>  vtable: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> {
</span></span><span style="display:flex;"><span>  a: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>  b: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Data</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>  s.a <span style="color:#f92672">+</span> s.b
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sub</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Data</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>  s.a <span style="color:#f92672">-</span> s.b
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> data <span style="color:#f92672">=</span> Data{a: <span style="color:#ae81ff">3</span>, b: <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> vtable <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// 指向drop
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">5</span>, <span style="color:#75715e">// vtable的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">8</span>, <span style="color:#75715e">// 内存对齐的size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    add <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    sub <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>  ];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> fat_pointer <span style="color:#f92672">=</span> FataPointer{data: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> data, vtable: <span style="color:#a6e22e">vtable</span>.as_ptr()};
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> dyn_ref <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { std::mem::transmute::<span style="color:#f92672">&lt;</span>FatPointer, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">dyn</span> Oper<span style="color:#f92672">&gt;</span>(fat_pointer)};
</span></span><span style="display:flex;"><span>  println!(<span style="color:#e6db74">&#34;add: {}&#34;</span>, dyn_ref.add());
</span></span><span style="display:flex;"><span>  println!(<span style="color:#e6db74">&#34;sub: {}&#34;</span>, dyn_ref.sub());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>&amp;[u8] -&gt; (*mut data, usize length)     <br>
&amp;str -&gt; (*mut data, usize length)      <br></p>
<h1 id="错误处理">错误处理 <a href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" class="anchor">🔗</a></h1><ul>
<li>新增类型来携带错误信息。</li>
<li>就地panic打开stack unwind</li>
</ul>
<p>Option: map() -&gt; Option<T>.  Combinators: and_then
Some -&gt; Some and None -&gt; None
or()  ok_or</p>
<p>Result</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">multiply</span>(first_number_str: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, second_number_str: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span>, ParseIntError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    first_number_str.parse::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>().and_then(<span style="color:#f92672">|</span>first_number<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        second_number_str.parse::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>().map(<span style="color:#f92672">|</span>second_number<span style="color:#f92672">|</span> first_number <span style="color:#f92672">*</span> second_number)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>？</li>
<li>Result::Ok(x), 返回x</li>
<li>Result::Err(e), return Err(e)</li>
<li>Option::Some(x), 返回x</li>
<li>Option::None, return None</li>
<li>unwrap()
<ul>
<li>Result::Ok(x), 返回x</li>
<li>Result::Err(e), panic</li>
<li>Option::Some(x), 返回x</li>
<li>Option::None, panic</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>do_something_may_fail()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// equals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">match</span> do_something_may_fail() {
</span></span><span style="display:flex;"><span>  Ok(v) <span style="color:#f92672">=&gt;</span> v,
</span></span><span style="display:flex;"><span>  Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// catch panic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> std::panic::catch_unwind(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>  panic!(<span style="color:#e6db74">&#34;oh no&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h1 id="lifetime">lifetime <a href="#lifetime" class="anchor">🔗</a></h1><p>函数返回引用时，除非是静态引用，那么这个引用一定和带有引用的某个输入参数有关。<br>
要建立正确的输入和返回值之间的关系，这个关系和函数内部的实现无关，只和函数的签名有关。</p>
<h1 id="unsafe">unsafe <a href="#unsafe" class="anchor">🔗</a></h1><p>标准库中unsafe。
Slice::get_unchecked() 执行未经检查的索引，允许随意地违反内存安全<br>
mem::transmute将一些值重新解释为具有给定的类型，以任意的方式绕过类型安全<br>
指向一个 Sized 类型的原始指针都有一个offset方法<br>
FFI（Foreign Function Interface）函数的调用都是不安全的<br></p>
<ul>
<li>对原始指针进行解引用。 例如链表实现中使用<code>node_ptr: NonNull&lt;Node&lt;T&gt;&gt; </code> ，node_ptr.as_ptr()获得Node的可变引用。</li>
</ul>
<p>NonNull<T> ,
std::ptr::Unique<T></p>
<h1 id="泛型">泛型 <a href="#%e6%b3%9b%e5%9e%8b" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BagOfHolding</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  item: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> bag_in_bag <span style="color:#f92672">=</span> BagOfHolding {
</span></span><span style="display:flex;"><span>  item: <span style="color:#a6e22e">BagOfHolding</span>{item: <span style="color:#e6db74">&#34;duang&#34;</span>},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;{}&#34;</span>, bag_in_bag.item.item);
</span></span></code></pre></div><h1 id="写算法需要熟练掌握的模块">写算法需要熟练掌握的模块 <a href="#%e5%86%99%e7%ae%97%e6%b3%95%e9%9c%80%e8%a6%81%e7%86%9f%e7%bb%83%e6%8e%8c%e6%8f%a1%e7%9a%84%e6%a8%a1%e5%9d%97" class="anchor">🔗</a></h1><p>Option， Result， mem， ptr， vec， String， str， iter。</p>
<p>Rc， Arc， Cell， RefCell， Box</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>  <span style="color:#75715e">//char 长度都为 4 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">let</span> chars <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;你好 🦀&#34;</span>.chars().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> memory_location <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">i32</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span></code></pre></div><p>todo  Cell Vs RefCell UnsafeCell(&amp;T --&gt; &amp;mut T)</p>
<p>Cell 不能get到inner ref， 所以修改inner是ok的<br>
impl !sync for Cell <br></p>
<p>Rc vs Arc <br></p>
<p>std::ptr::NonNull<br></p>
<h2 id="optiont-会用到的api">Option<T> 会用到的API <a href="#optiont-%e4%bc%9a%e7%94%a8%e5%88%b0%e7%9a%84api" class="anchor">🔗</a></h2><p>as_ref(): Converts <code>&amp;Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code>.<code>&lt;br&gt; as_mut(): from</code>&amp;mut Option<T><code>-&gt;</code>Option&lt;&amp;mut T&gt;` <br></p>
<p>Option 与 Result 常见方法的对比: <br></p>
<table>
<thead>
<tr>
<th>Option<T></th>
<th>函数的功能</th>
<th>Result&lt;T, E&gt;</th>
<th>函数的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_some(&amp;self), is_none()</td>
<td></td>
<td>is_ok(&amp;self), is_err()</td>
<td></td>
</tr>
<tr>
<td>ok_or<E>(self, err: E) -&gt; Result&lt;T, E&gt;()</td>
<td>-&gt;Result&lt;T, E&gt;</td>
<td>ok(self) -&gt; Option<T>, err(self) -&gt; Option<E></td>
<td>Result-&gt;Option</td>
</tr>
<tr>
<td>as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;</td>
<td>&amp;Option&lt;T -&gt; Option&lt;&amp;T&gt;</td>
<td>as_ref(&amp;self) -&gt;Result&lt;&amp;T, &amp;E&gt;</td>
<td></td>
</tr>
<tr>
<td>as_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;</td>
<td>&amp;mut Option<T> -&gt; Option&lt;&amp;mut T&gt;</td>
<td>as_mut(&amp;mut self) -&gt; Result&lt;&amp;mut T, &amp;mut E&gt;</td>
<td></td>
</tr>
<tr>
<td>map&lt;U, F&gt;(self, f: F) -&gt; Option<U> where F: FnOnce(T) -&gt; U</td>
<td>consume the orignal</td>
<td>map(self, op: F)</td>
<td>Result&lt;T, E&gt; -&gt; Result&lt;U, E&gt;</td>
</tr>
<tr>
<td>as_deref(&amp;self) -&gt; Option&lt;&amp;<T as Deref>::Target&gt; where T: Deref,</td>
<td>&amp;Option&lt;T -&gt; Option&lt;&amp;T::Target&gt;</td>
<td>as_deref(&amp;self) -&gt; &lt;&amp;<T as deref>::Target, &amp;E&gt;</td>
<td>Result&lt;String, u32&gt; -&gt; Result&lt;&amp;str, &amp;u32&gt;</td>
</tr>
<tr>
<td>as_deref_mut(&amp;mut self) -&gt; Option&lt;&amp;mut <T as Deref>::Target&gt; where T: DerefMut,</td>
<td>&amp;mut Option<T> -&gt; Option&lt;&amp;mut T::Target&gt;</td>
<td>as_deref_mut(&amp;mut self)</td>
<td></td>
</tr>
<tr>
<td>expect(self, msg: &amp;str)</td>
<td>may panic</td>
<td>expect(self, msg: &amp;str) -&gt; T</td>
<td>may panic</td>
</tr>
<tr>
<td>unwrap(self) -&gt; T</td>
<td>my panic</td>
<td>unwrap(self)-&gt;T</td>
<td>may panic</td>
</tr>
<tr>
<td>unwrap_or_default(self)-&gt; T where T: Default,</td>
<td>no panic</td>
<td></td>
<td></td>
</tr>
<tr>
<td>take(&amp;mut self) -&gt; Option<T></td>
<td>leave none, return Option</td>
<td></td>
<td></td>
</tr>
<tr>
<td>replace(&amp;mut self, value: T) -&gt; Option<T></td>
<td>change and return old value</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  None,
</span></span><span style="display:flex;"><span>  Some(T),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_ref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> text: Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Some(<span style="color:#e6db74">&#34;Hello, world!&#34;</span>.to_string());
</span></span><span style="display:flex;"><span><span style="color:#75715e">// First, cast `Option&lt;String&gt;` to `Option&lt;&amp;String&gt;` with `as_ref`,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// then consume *that* with `map`, leaving `text` on the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> text_length: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> text.as_ref().map(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s.len());
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;still can print text: {text:?}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expect() <span style="color:#75715e">// panics with a provided custom message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>unwrap() <span style="color:#75715e">// panics with a generic message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>unwrap_or(<span style="color:#e6db74">&#34;abc&#34;</span>) <span style="color:#75715e">// returns the provided default value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>ok_or() <span style="color:#75715e">//Some(v) to Ok(v), and None to Err(err)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>filter() <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>map()    <span style="color:#75715e">//  Option&lt;T&gt; to Option&lt;U&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>take()   <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>replace() <span style="color:#75715e">//
</span></span></span></code></pre></div><p>and_then()</p>
<p>take(): <br></p>
<p>deref_mut() <br></p>
<h2 id="asreft">AsRef<T> <a href="#asreft" class="anchor">🔗</a></h2><p>String -&gt; &amp;str (&quot;abc&quot;.to_string().as_ref())</p>
<h1 id="stdsyncatmoic-memory-ordering">std::sync::atmoic, memory ordering <a href="#stdsyncatmoic-memory-ordering" class="anchor">🔗</a></h1><p>compare_exchange , compare_exchange_weak<br></p>
<h1 id="包模块可见性">包，模块，可见性 <a href="#%e5%8c%85%e6%a8%a1%e5%9d%97%e5%8f%af%e8%a7%81%e6%80%a7" class="anchor">🔗</a></h1><p>模块foo可以有2种表示： <br></p>
<ul>
<li>一个名为 foo.rs 的文件</li>
<li>在名为 foo 的目录，里面有一个叫 mod.rs 文件</li>
</ul>
<h1 id="stdcmd包">std::cmd包 <a href="#stdcmd%e5%8c%85" class="anchor">🔗</a></h1><p>整个逻辑只在<code>/library/core/src/cmp.rs</code>中定义清楚。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::Eq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Eq: PartialEq<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> {}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::PartialEq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> PartialEq<span style="color:#f92672">&lt;</span>Rhs <span style="color:#f92672">=</span> Self<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span> Rhs: <span style="color:#f92672">?</span>Sized,
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Required Methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eq</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Rhs</span>) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::PartialOrd 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> PartialOrd<span style="color:#f92672">&lt;</span>Rhs: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">=</span> Self<span style="color:#f92672">&gt;</span>: PartialEq<span style="color:#f92672">&lt;</span>Rhs<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Required Methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">partial_cmp</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Rhs</span>) -&gt; Option<span style="color:#f92672">&lt;</span>Ordering<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::Ord
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Ord: Eq <span style="color:#f92672">+</span> PartialOrd<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Required Methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Ordering</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">min</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">clamp</span>(self, min: <span style="color:#a6e22e">Self</span>, max: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> <span style="color:#66d9ef">where</span> Self: PartialOrd<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Ordering</span> {
</span></span><span style="display:flex;"><span>    Less <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    Equal <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    Greater <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="泛型编程">泛型编程 <a href="#%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b" class="anchor">🔗</a></h1><p>是否有必要在此刻就把类型定死? <br>
通过泛型静态绑定推迟到编译期确定类型，trait obj推迟到运行期确定类型。<br></p>
<h1 id="语法问题">语法问题 <a href="#%e8%af%ad%e6%b3%95%e9%97%ae%e9%a2%98" class="anchor">🔗</a></h1><p>ref pattern</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">ref</span> ref_a1 <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ref_a2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a; <span style="color:#75715e">// the same effect
</span></span></span></code></pre></div><h1 id="类型的嵌套">类型的嵌套 <a href="#%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%b5%8c%e5%a5%97" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>String<span style="color:#960050;background-color:#1e0010">，</span> Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, Box<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, Unique<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> T
</span></span></code></pre></div><p><code>dyn (Fn() + Send + 'static)</code>是什么意思？<br></p>
<p>Fn() 不带参数和返回值的闭包，可以被Send到其他线程中，具有捕获变量的所有权。
’static是指没有对上下文中的非静态变量进行引用。</p>
<h1 id="对象安全-trait-object">对象安全， trait object <a href="#%e5%af%b9%e8%b1%a1%e5%ae%89%e5%85%a8-trait-object" class="anchor">🔗</a></h1><p>trait object类型擦除， (data, vatable(funcname -&gt; func pointer)) <br></p>
<p>trait中的方法仅仅依赖于trait中的定义。</p>
<p>（size, shape of argument, ）。
return value： 不能是Self，trait object类型擦除，无法返回与trait无关的具体类型。
shape of argument 不能带泛型。</p>
<h1 id="any-trait"><code>Any</code> trait <a href="#any-trait" class="anchor">🔗</a></h1><p>Deref, Drop, Copy, Any trait</p>
<p>Send &amp; Sync</p>
<p>?Size</p>
<h1 id="fn-fnmut-fnonce-区别">Fn FnMut FnOnce 区别 <a href="#fn-fnmut-fnonce-%e5%8c%ba%e5%88%ab" class="anchor">🔗</a></h1><p><strong>闭包去实现哪种<code>Fn, FnMut, FnOnce</code>trait与move无关，与如何捕获变量无关。</strong><br>
<strong>Fn FnMut FnOnce与闭包如何使用捕获到的值有关。</strong><br></p>
<p>闭包就是捕获外部变量的结构体，加一段代码<br></p>
<p>closure 是结构体（捕获的变量）的语法糖，闭包逻辑部分在代码段中。<br>
闭包的调用： Fn::call(第一个参数就是闭包结构体...) Fn：call_</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 移走匿名结构体中变量的closure实现 FnOnce
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FnOnce::call_once(self, args: <span style="color:#a6e22e">Args</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不会移走匿名结构体中变量但修改的closure实现 FnMut
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FnMut::call_mut(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, args: <span style="color:#a6e22e">Args</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//不会修改匿名结构体中变量的closure实现 Fn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Fn: <span style="color:#a6e22e">call</span>(<span style="color:#f92672">&amp;</span>self, args: <span style="color:#a6e22e">Args</span> -&gt; <span style="color:#a6e22e">Self</span>::Output);
</span></span></code></pre></div><h1 id="所有权move语义借用生命周期的推进关系">所有权，move语义，借用，生命周期的推进关系 <a href="#%e6%89%80%e6%9c%89%e6%9d%83move%e8%af%ad%e4%b9%89%e5%80%9f%e7%94%a8%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%9a%84%e6%8e%a8%e8%bf%9b%e5%85%b3%e7%b3%bb" class="anchor">🔗</a></h1><p>为了适应内存的ownership&amp;move语义，引入borrow &amp; reference。<br>
带来新问题是所有权和使用权分隔了，让引用和原始值的内存空间独立了。<br>
但是两者具有逻辑关系上的约束： 引用只能在原始值存在的前提下才有意义。<br>
引入生命周期lifetime到语法中。<br></p>
<p>例如： 一个fn返回了引用，如果是引用fn的local变量则❌，如果是引用fn的参数，那么compiler需要知道传入的参数的存活时间是否支撑这个引用的有效性(新引用的生命周期只能是被引用值的生命周期的区间子集)。</p>
<p>Copy：复制语义非move语义。Clone用从&amp;T中创建副本T。<br>
copy是浅拷贝，是编译器自动调用。 clone是深拷贝，程序员手动调用。<br></p>
<h1 id="traits的内存表示">traits的内存表示 <a href="#traits%e7%9a%84%e5%86%85%e5%ad%98%e8%a1%a8%e7%a4%ba" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> writer: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::io::Write <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf;
</span></span></code></pre></div><pre tabindex="0"><code>      trait object( data    vptr) 
                    .          . 
                   .            .
                  .              .
                .                 . 
buf(buffer, capacity, lenght)      vtable impl Write for Vec&lt;u8&gt;
                                            析构函数，size, align
                                            write() -&gt;
                                            flush() -&gt;
</code></pre><p>c++是将vptr和对象保存在一起。给基础类型int，string扩展方法就做不到了。</p>
<h1 id="attribute-属性">attribute 属性 <a href="#attribute-%e5%b1%9e%e6%80%a7" class="anchor">🔗</a></h1><p><code>#[allow(non_camlel_case_types)]</code>
<code>#[cfg(windows)]</code>
<code>#[derive(Debug)]</code></p>
<h1 id="rust-生命宏-过程宏-rust中的插桩">rust 生命宏， 过程宏， rust中的插桩 <a href="#rust-%e7%94%9f%e5%91%bd%e5%ae%8f-%e8%bf%87%e7%a8%8b%e5%ae%8f-rust%e4%b8%ad%e7%9a%84%e6%8f%92%e6%a1%a9" class="anchor">🔗</a></h1><p>why 为什么需要宏？</p>
<p>宏是扩展语言的一种方式，元编程。</p>
<p>声明宏： 对代码模版做简单替换。 <code>macro_rules!</code>
过程宏： 可以深度定制和生产代码。
函数宏：
属性宏： <code>#[tokio::main]</code>
派生宏： <code>#[derive(Debug)]</code></p>
<p>利用过程宏修改ast来实现fn进入和出来时打印日志。</p>
<h1 id="子类型-类型产生器-协变逆变不变">子类型， 类型产生器， 协变，逆变，不变 <a href="#%e5%ad%90%e7%b1%bb%e5%9e%8b-%e7%b1%bb%e5%9e%8b%e4%ba%a7%e7%94%9f%e5%99%a8-%e5%8d%8f%e5%8f%98%e9%80%86%e5%8f%98%e4%b8%8d%e5%8f%98" class="anchor">🔗</a></h1><pre tabindex="0"><code>T: U , a: U, b: T.
</code></pre><h1 id="t-mut-t">&amp;T &amp;mut T <a href="#t-mut-t" class="anchor">🔗</a></h1><p>&amp;T: 共享引用， &amp;mut T 独占引用<br></p>
<h1 id="rust-内存模型">rust 内存模型 <a href="#rust-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" class="anchor">🔗</a></h1><ul>
<li>acquire 用于load， 读</li>
<li>release 用于store，写</li>
<li>seq     相当于memory barrier</li>
</ul>

    </div>

    
        <div class="tags">
            
                <a href="http://brettkk.github.io/tags/rust">rust</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <script src="https://utteranc.es/client.js"
repo="brettKK/brettkk.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>  

    <div class="copyright">
    
       © Copyright 
       2023 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-cactus-plus'>nodejh</a>
      </div>
    
</footer>




  </body>
</html>
