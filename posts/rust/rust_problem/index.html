<!DOCTYPE html>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<html lang="zh-cn">
  <head>
    <title>rust相关的环境问题 &#43; 类型系统疑问 | brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="属于名词解释性的文章，知道就是知道，知道是设计者是这么做得而">
<meta name="generator" content="Hugo 0.103.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/zenburn.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" href="http://brettkk.github.io/css/syntax.css" />


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">rust相关的环境问题 &#43; 类型系统疑问</h1>

    <div class="tip">
        <time datetime="2022-11-21 11:33:56 &#43;0800 CST">Nov 21, 2022</time>
        <span class="split">
          ·
        </span>
        <span>
          5744 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          12 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#阅读rust-lang时遇到的问题">阅读rust-lang时遇到的问题</a>
      <ul>
        <li><a href="#单步调试找不到源代码">单步调试找不到源代码?</a></li>
      </ul>
    </li>
    <li><a href="#main方法的return类型"><code>main</code>方法的return类型</a></li>
    <li><a href="#语言中的sugar">语言中的sugar</a>
      <ul>
        <li><a href="#coercion">coercion</a></li>
      </ul>
    </li>
    <li><a href="#borrow---asref">Borrow  ↔️ AsRef</a></li>
    <li><a href="#trait的关联类型">trait的关联类型</a></li>
    <li><a href="#ref-语法问题">ref 语法问题</a></li>
    <li><a href="#static">'static</a></li>
    <li><a href="#多重引用">多重引用</a></li>
    <li><a href="#t-as-_-"><code>T as _</code> ？</a></li>
    <li><a href="#智能指针">智能指针</a></li>
    <li><a href="#pint-unpin">Pin<T>, Unpin</a></li>
    <li><a href="#send-sync">Send, Sync</a></li>
    <li><a href="#trait-object-dst"><code>trait object</code> DST</a></li>
    <li><a href="#sized-sized"><code>Sized</code> <code>?Sized</code></a></li>
    <li><a href="#对象安全-trait-object">对象安全， trait object</a></li>
    <li><a href="#错误处理">错误处理</a></li>
    <li><a href="#lifetime">lifetime</a></li>
    <li><a href="#unsafe">unsafe</a></li>
    <li><a href="#type-----trait">type &lt;---&gt; trait</a></li>
    <li><a href="#泛型">泛型</a></li>
    <li><a href="#写算法需要熟练掌握的模块">写算法需要熟练掌握的模块</a>
      <ul>
        <li><a href="#optiont-会用到的api">Option<T> 会用到的API</a></li>
        <li><a href="#asreft">AsRef<T></a></li>
      </ul>
    </li>
    <li><a href="#包模块可见性">包，模块，可见性</a></li>
    <li><a href="#stdcmd包">std::cmd包</a></li>
    <li><a href="#泛型编程">泛型编程</a></li>
    <li><a href="#类型的嵌套">类型的嵌套</a></li>
    <li><a href="#any-trait"><code>Any</code> trait</a></li>
    <li><a href="#fn-fnmut-fnonce-区别"><code>Fn FnMut FnOnce</code> 区别</a></li>
    <li><a href="#rust-生命宏-过程宏-rust中的插桩">rust 生命宏， 过程宏， rust中的插桩</a></li>
    <li><a href="#子类型-类型产生器-协变逆变不变">子类型， 类型产生器， 协变，逆变，不变</a></li>
    <li><a href="#t-vs-mut-t">&amp;T vs &amp;mut T</a></li>
    <li><a href="#rust-内存模型">rust 内存模型</a></li>
    <li><a href="#操作符号重载">操作符号重载</a></li>
    <li><a href="#哪些操作可能会ownership-move-">哪些操作可能会ownership move ？</a></li>
    <li><a href="#rust中的类型转换">rust中的类型转换</a></li>
    <li><a href="#rust源码库中的重导出">rust源码库中的重导出</a></li>
    <li><a href="#cargo">cargo</a></li>
    <li><a href="#在vscode下配置rust项目的阅读和debug">在vscode下配置rust项目的阅读和debug</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>属于名词解释性的文章，知道就是知道，知道是设计者是这么做得而已。。。balabala。不属于原理性的知识。</p>
<h1 id="阅读rust-lang时遇到的问题">阅读rust-lang时遇到的问题 <a href="#%e9%98%85%e8%af%bbrust-lang%e6%97%b6%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98" class="anchor">🔗</a></h1><p>  原因是git大仓下有些submodule, 这些submodule在clone时并不会随大仓一起下载到本地。<br>
  本地调试 <code>rustc -g main.rs</code>， <code>lldb main</code> ，<code>b main</code>， <code>run</code>， <code>step</code></p>
<h2 id="单步调试找不到源代码">单步调试找不到源代码? <a href="#%e5%8d%95%e6%ad%a5%e8%b0%83%e8%af%95%e6%89%be%e4%b8%8d%e5%88%b0%e6%ba%90%e4%bb%a3%e7%a0%81" class="anchor">🔗</a></h2><p>  遇到调用库函数时进入到汇编, 未跳到源代码的位置。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//settings.json
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;lldb.executable&#34;</span>: <span style="color:#e6db74">&#34;rust-lldb&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;lldb.launch.sourceLanguages&#34;</span>: [<span style="color:#e6db74">&#34;rust&#34;</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;lldb.launch.sourceMap&#34;</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;/rustc/e75aab045fc476f176a58c408f6b06f0e275c6e1/&#34;</span>: 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;/Users/brett/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust&#34;</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>  增加配置后，rust/library里的core, std, alloc都可以step in进去了。 但是compile相关的代码还是step in到了汇编。<br>
<img src="/rust/rustup_copy_compile.png" height = "400" /><br>
复制后， lldb debug step into compiler了。<br>
<img src="/rust/rust_step_in_compiler.png" width = "605" /><br></p>
<h1 id="main方法的return类型"><code>main</code>方法的return类型 <a href="#main%e6%96%b9%e6%b3%95%e7%9a%84return%e7%b1%bb%e5%9e%8b" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Option<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>              <span style="color:#f92672">^^^^^^^^^^^^^^^^^^^^^^^^^^^</span> <span style="color:#960050;background-color:#1e0010">`</span>main<span style="color:#960050;background-color:#1e0010">`</span> can only <span style="color:#66d9ef">return</span> types that implement <span style="color:#960050;background-color:#1e0010">`</span>Termination<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">=</span> help: <span style="color:#a6e22e">consider</span> using <span style="color:#960050;background-color:#1e0010">`</span>()<span style="color:#960050;background-color:#1e0010">`</span>, or a <span style="color:#960050;background-color:#1e0010">`</span>Result<span style="color:#960050;background-color:#1e0010">`</span>
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/std/process/trait.Termination.html" target="_blank" rel="noopener">main函数的return type必须实现std::process::Termination特征</a><br>，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> Infallible
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> <span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> ()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Termination <span style="color:#66d9ef">for</span> ExitCode
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Termination</span>, E: <span style="color:#a6e22e">Debug</span><span style="color:#f92672">&gt;</span> Termination <span style="color:#66d9ef">for</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h1 id="语言中的sugar">语言中的sugar <a href="#%e8%af%ad%e8%a8%80%e4%b8%ad%e7%9a%84sugar" class="anchor">🔗</a></h1><h2 id="coercion">coercion <a href="#coercion" class="anchor">🔗</a></h2><p>  弱化类型去匹配方法的签名。 &amp;mut T to &amp;T。<br>
  <code>.</code>操作符的背后（编译器）做了很多操作<br>
  <code>auto-referencing</code>, <code>auto-dereferencing</code>, and <code>coercion until types match</code>。
  <a href="https://rustc-dev-guide.rust-lang.org/method-lookup.html" target="_blank" rel="noopener">编译器的method lookup</a><br>
  Method Resolution: Derefs or borrow x until x.f() works. <br>
  有两种coercion： <code>auto_ref</code>, <code>auto_deref</code></p>
<ul>
<li>auto_ref,  T -&gt; &amp;T, mut T -&gt; &amp;mut T (单纯的想要引用T)
<ul>
<li>object.something(), rustc 可以添加&amp;object， &amp;mut object, *object来是caller的类型与something的签名匹配。</li>
</ul>
</li>
<li>auto_deref, 自动调用Deref::deref (Defref描述了外部类型转为内部类型，一般用于智能指针）
<ul>
<li>Box<T> 实现了Deref。  <code>&amp;*x 相当于 &quot;reborrow&quot;</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a: Box<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Box::new(<span style="color:#e6db74">&#34;hello&#34;</span>.to_owned());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b: <span style="color:#66d9ef">&amp;</span>String <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;*</span>a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> c: <span style="color:#66d9ef">&amp;</span>String <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>(std::ops::Deref::deref(<span style="color:#f92672">&amp;</span>a)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>Box::new(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    test(<span style="color:#f92672">&amp;**</span>a); <span style="color:#75715e">// one * to dereference the Box, get &amp;i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// one * to dereference the &amp;， get i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// reborrow with &amp;, get &amp;i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>(a: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i32</span>) { println!(<span style="color:#e6db74">&#34;{}&#34;</span>, <span style="color:#f92672">*</span>a) }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyI32</span>(<span style="color:#66d9ef">i32</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> MyI32 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_string</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;&amp;self={:?}&#34;</span>, self); <span style="color:#75715e">// auto add *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        println!(<span style="color:#e6db74">&#34;*self={:?}&#34;</span>, <span style="color:#f92672">*</span>self);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_my_i32</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mi32 <span style="color:#f92672">=</span> MyI32(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    mi32.print_string();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> box_my_i32 <span style="color:#f92672">=</span> Box::new(mi32);
</span></span><span style="display:flex;"><span>    box_my_i32.print_string(); <span style="color:#75715e">// Box&lt;MyI32&gt; -&gt; &amp;MyI32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">&amp;</span>box_my_i32).print_string();
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>box_my_i32).print_string();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 多了一个&amp; ，compile自动去掉来match类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">&amp;*</span>box_my_i32).print_string();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="borrow---asref">Borrow  ↔️ AsRef <a href="#borrow---asref" class="anchor">🔗</a></h1><p>  很相近，但不同<br>
  <code>&amp;</code>借用（引用）是<code>blanket implement</code>，所有类型都实现了<code>Borrow</code> <br>
  <code>AsRef</code>是引用到引用的转换。 定制化 <code>as_ref</code> 后的类型, 可能self不同的另外一种（String -&gt; &amp;str）, 可能是self结构下的某一个字段的引用。<br></p>
<ul>
<li>对值类型的转换 <code>From&lt;T&gt;</code>, <code>Into&lt;T&gt;</code></li>
<li>对引用类型的转换 <code>AsRef&lt;T&gt;</code>, <code>AsMut&lt;T&gt;</code></li>
</ul>
<p>Borrow在RefCell上有实现， 同时Borrow有兜底实现<code>impl&lt;T&gt; Borrow&lt;T&gt; for T</code> 得到&amp;T。</p>
<p>AsRef也有兜底实现。</p>
<h1 id="trait的关联类型">trait的关联类型 <a href="#trait%e7%9a%84%e5%85%b3%e8%81%94%e7%b1%bb%e5%9e%8b" class="anchor">🔗</a></h1><p><strong>为什么需要关联类型？使用上不方便的地方。</strong></p>
<h1 id="ref-语法问题">ref 语法问题 <a href="#ref-%e8%af%ad%e6%b3%95%e9%97%ae%e9%a2%98" class="anchor">🔗</a></h1><p>ref pattern</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">ref</span> ref_a1 <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ref_a2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a; <span style="color:#75715e">// the same effect
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">ref</span> ref_x1 <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ref_x2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x; <span style="color:#75715e">// ref_x1, ref_x2 same
</span></span></span></code></pre></div><h1 id="static">'static <a href="#static" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Trait bound
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// T  type does not contain any non-static references
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">generic</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">&#39;</span>static <span style="color:#f92672">+</span> <span style="color:#66d9ef">impl</span> Debug<span style="color:#f92672">&gt;</span>(x: <span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>  println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>genric(i); <span style="color:#75715e">//✅
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>genric(<span style="color:#f92672">&amp;</span>i) <span style="color:#75715e">//❌
</span></span></span></code></pre></div><h1 id="多重引用">多重引用 <a href="#%e5%a4%9a%e9%87%8d%e5%bc%95%e7%94%a8" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vec1 <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 对 vec1 的 `iter()` 举出 `&amp;i32`, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `find` 方法会把迭代器元素的引用传给闭包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 传给闭包的类型是&amp;&amp;i32 用&amp;&amp;x解构， x 类型为i32。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;find 2 in vec1: {:?}&#34;</span>, vec1.iter().find(<span style="color:#f92672">|&amp;&amp;</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>));
</span></span></code></pre></div><h1 id="t-as-_-"><code>T as _</code> ？ <a href="#t-as-_-" class="anchor">🔗</a></h1><p>AtomicPtr&lt;()&gt;， *mut T as _ <br>
Even_vtable, Odd_vtable 为什么要区分？</p>
<h1 id="智能指针">智能指针 <a href="#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" class="anchor">🔗</a></h1><p>在rust中trait决定了类型的行为， 智能指针的行为涉及到<code>Deref trait</code> , <code>Drop trait</code>, 拥有指针语义，拥有内存自动管理。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Deref {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Target</span>: <span style="color:#f92672">?</span>size;
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">/// Dereference the value 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>  <span style="color:#e6db74">/// *X =》 *(X.deref())
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::Target;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Box</code></p>
<p><code>Vec&lt;T&gt;, String</code></p>
<p><code>Rc, Arc</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RcBox</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  strong: <span style="color:#a6e22e">Cell</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>  weak: <span style="color:#a6e22e">Cell</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>  value: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArcInner</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  strong: <span style="color:#a6e22e">atomic</span>::AtmoicUsize,
</span></span><span style="display:flex;"><span>  weak: <span style="color:#a6e22e">atmoic</span>::AtomicUsize,
</span></span><span style="display:flex;"><span>  data: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Cell, RefCell</code> 内部可变性<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"></code></pre></div><p><code>Mutex, RwLock</code></p>
<p><code>Rc&lt;RefCell&lt;T&gt;&gt;</code>  一个RefCell<T> 可以有多个所有者。
<code>RefCell&lt;Rc&lt;T&gt;&gt;</code> <br></p>
<p>Cell， RefCell在功能上没有区别。<br>
Cell<T> 使用于 T实现了Copy的情况<br>
RefCell<T> 内部可变， 一个borrow_mut修改后，其他引用可以看到修改。 <br></p>
<p>Rc --downgrade() --&gt; Weak <br>
Weak -- Upgrade() --&gt; Option<Rc> <br></p>
<p>Box<T> -&gt; Unqiue<T> -&gt; NonNull<T> --&gt; *const T, *mut T <br></p>
<h1 id="pint-unpin">Pin<T>, Unpin <a href="#pint-unpin" class="anchor">🔗</a></h1><p>很多情况下，其实Pin是用不到的。因为大多数情形下，都实现Unpin Traits。<br>
在引入的async/await编程中, Futrue的移动, 如果结构体包含了自引用， 当对象发生移动时引用的指针会失效，所以需要Pin住<br>
Pin对象的手段： 禁止获取<code>&amp;mut T</code>.</p>
<p><code>Pin&lt;P&gt;</code>, 包裹的p（必须是实现<code>Deref trait</code>的对象）是指针指向原始类型T， 理解为 <code>Pin&lt;P&lt;T&gt;&gt;</code> <br>
给定 <code>Pin&lt;P&lt;T&gt;&gt;</code>类型的数据，只要 <code>T</code> 不满足 <code>Unpin trait</code>，则 <code>Safe Rust</code> 下无法获得 <code>&amp;mut T</code>和 <code>T</code>，从而让 <code>T</code> 不能被 <code>move</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Example</span> {
</span></span><span style="display:flex;"><span>    data: String,
</span></span><span style="display:flex;"><span>    ptr: <span style="color:#a6e22e">NonNull</span><span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">Deref</span><span style="color:#f92672">&lt;</span>Target: Unpin<span style="color:#f92672">&gt;&gt;</span> Pin<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(pointer: <span style="color:#a6e22e">P</span>) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="send-sync">Send, Sync <a href="#send-sync" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> RwLock<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> RwLock<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Mutex<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">+</span> Send<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> Mutex<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: Send<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Sender<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">!</span>Sync <span style="color:#66d9ef">for</span> Sender<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// T: Send + Sync， 才为Arc实现Send。所以Arc&lt;RefCell&gt; 不能在线程spawn时使用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Send <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span> T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Sync <span style="color:#66d9ef">for</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span> T: Sync <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized
</span></span></code></pre></div><p>Arc::new(RwLock::new(mpsc::Sender<T>))</p>
<p>Sender<T> no sync -&gt; RwLock no sync -&gt; Arc is not send and not sync.</p>
<p>Sender<T> is &quot;thread safe&quot; in that it can be sent between threads, but it cannot be shared between threads.  <br></p>
<ul>
<li>Send + Sync -&gt; 大多数类型都是的</li>
<li>！Send + Sync -&gt;</li>
<li>！Send + ! Sync -&gt;  Rc， Raw pointer， Arc<T> where T: Send + sync</li>
<li>Send + !Sync -&gt;  内部可变的UnsafeCell, mpsc::Sender, Cell, RefCell</li>
</ul>
<h1 id="trait-object-dst"><code>trait object</code> DST <a href="#trait-object-dst" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> writer: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::io::Write <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>      <span style="color:#66d9ef">trait</span> object( data    vptr) 
</span></span><span style="display:flex;"><span>                    .          . 
</span></span><span style="display:flex;"><span>                   .            .
</span></span><span style="display:flex;"><span>                  .              .
</span></span><span style="display:flex;"><span>                .                 . 
</span></span><span style="display:flex;"><span>buf(buffer, capacity, lenght)      vtable <span style="color:#66d9ef">impl</span> Write <span style="color:#66d9ef">for</span> Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                                            <span style="color:#960050;background-color:#1e0010">析构函数，</span>size, align
</span></span><span style="display:flex;"><span>                                            write() -&gt;
</span></span><span style="display:flex;"><span>                                            <span style="color:#a6e22e">flush</span>() -&gt;
</span></span></code></pre></div><p>c++是将vptr和对象保存在一起。给基础类型int，string扩展方法就做不到了。
<a href="https://play.rust-lang.org/?gist=41ac3acde9ea070db48add40d5d12831&amp;version=nightly" target="_blank" rel="noopener">NonNull</a></p>
<p>类型占用了多少内存? &amp;dyn Trait -&gt; (*mut data, *mut vtable) <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Oper {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sub</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">i32</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[repr(C)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FatPointer</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  data: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">mut</span> Data,
</span></span><span style="display:flex;"><span>  vtable: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span> {
</span></span><span style="display:flex;"><span>  a: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>  b: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Data</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>  s.a <span style="color:#f92672">+</span> s.b
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sub</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Data</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>  s.a <span style="color:#f92672">-</span> s.b
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> data <span style="color:#f92672">=</span> Data{a: <span style="color:#ae81ff">3</span>, b: <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> vtable <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// 指向drop
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">5</span>, <span style="color:#75715e">// vtable的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">8</span>, <span style="color:#75715e">// 内存对齐的size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    add <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    sub <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>  ];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> fat_pointer <span style="color:#f92672">=</span> FataPointer{data: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> data, vtable: <span style="color:#a6e22e">vtable</span>.as_ptr()};
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> dyn_ref <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { std::mem::transmute::<span style="color:#f92672">&lt;</span>FatPointer, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">dyn</span> Oper<span style="color:#f92672">&gt;</span>(fat_pointer)};
</span></span><span style="display:flex;"><span>  println!(<span style="color:#e6db74">&#34;add: {}&#34;</span>, dyn_ref.add());
</span></span><span style="display:flex;"><span>  println!(<span style="color:#e6db74">&#34;sub: {}&#34;</span>, dyn_ref.sub());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="sized-sized"><code>Sized</code> <code>?Sized</code> <a href="#sized-sized" class="anchor">🔗</a></h1><h1 id="对象安全-trait-object">对象安全， trait object <a href="#%e5%af%b9%e8%b1%a1%e5%ae%89%e5%85%a8-trait-object" class="anchor">🔗</a></h1><p>trait object类型擦除， (data, vatable(funcname -&gt; func pointer)) <br></p>
<ul>
<li>trait的所有父trait都是对象安全的</li>
<li>不能以Sized为父trait</li>
<li>所有关联函数能从trait obj进行分发
<ul>
<li>不带任何类型参数。shape of argument 不能带泛型。</li>
<li>方法除了接收方（第一个参数）之外，其他地方不能使用Self类型。trait object类型擦除，无法返回与trait无关的具体类型。</li>
<li>接收方是引用或者指针的形式。&amp;Self, &amp;mut self, Box<Self></li>
<li>没有where Self：Sized
<Strong>trait中的方法仅仅依赖于trait中的定义。</Strong><br></li>
</ul>
</li>
</ul>
<h1 id="错误处理">错误处理 <a href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" class="anchor">🔗</a></h1><ul>
<li>？</li>
<li>Result::Ok(x), 返回x</li>
<li>Result::Err(e), return Err(e)</li>
<li>Option::Some(x), 返回x</li>
<li>Option::None, return None</li>
<li>unwrap()
<ul>
<li>Result::Ok(x), 返回x</li>
<li>Result::Err(e), panic</li>
<li>Option::Some(x), 返回x</li>
<li>Option::None, panic</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">multiply</span>(first_number_str: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, second_number_str: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span>, ParseIntError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    first_number_str.parse::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>().and_then(<span style="color:#f92672">|</span>first_number<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        second_number_str.parse::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>().map(<span style="color:#f92672">|</span>second_number<span style="color:#f92672">|</span> first_number <span style="color:#f92672">*</span> second_number)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>do_something_may_fail()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// equals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">match</span> do_something_may_fail() {
</span></span><span style="display:flex;"><span>  Ok(v) <span style="color:#f92672">=&gt;</span> v,
</span></span><span style="display:flex;"><span>  Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// catch panic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> std::panic::catch_unwind(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>  panic!(<span style="color:#e6db74">&#34;oh no&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h1 id="lifetime">lifetime <a href="#lifetime" class="anchor">🔗</a></h1><p><strong>函数返回引用时，除非是静态引用，那么这个引用一定和带有引用的某个输入参数有关。</strong><br>
<strong>要建立正确的输入和返回值之间的关系，这个关系和函数内部的实现无关，只和函数的签名有关。</strong></p>
<h1 id="unsafe">unsafe <a href="#unsafe" class="anchor">🔗</a></h1><p>标准库中unsafe。
Slice::get_unchecked() 执行未经检查的索引，允许随意地违反内存安全<br>
mem::transmute将一些值重新解释为具有给定的类型，以任意的方式绕过类型安全<br>
指向一个 Sized 类型的原始指针都有一个offset方法<br>
FFI（Foreign Function Interface）函数的调用都是不安全的<br>
对原始指针进行解引用。 例如链表实现中使用<code>node_ptr: NonNull&lt;Node&lt;T&gt;&gt; </code> ，node_ptr.as_ptr()获得Node的可变引用。</p>
<p>NonNull<T> , std::ptr::Unique<T></p>
<h1 id="type-----trait">type &lt;---&gt; trait <a href="#type-----trait" class="anchor">🔗</a></h1><p>impl Trait_X for Type_Y</p>
<p>Type_Y -&gt; 基本类型，组合类型struct/enum， 闭包，ref，ptr， trait。 <br></p>
<p>Trait_X -&gt; ...</p>
<p>给标准库中的集合直接实现 标准库中的trait是不允许的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyVec</span>(Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> std::fmt::Display <span style="color:#66d9ef">for</span> MyVec {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="泛型">泛型 <a href="#%e6%b3%9b%e5%9e%8b" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BagOfHolding</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  item: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> bag_in_bag <span style="color:#f92672">=</span> BagOfHolding {
</span></span><span style="display:flex;"><span>  item: <span style="color:#a6e22e">BagOfHolding</span>{item: <span style="color:#e6db74">&#34;duang&#34;</span>},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;{}&#34;</span>, bag_in_bag.item.item);
</span></span></code></pre></div><h1 id="写算法需要熟练掌握的模块">写算法需要熟练掌握的模块 <a href="#%e5%86%99%e7%ae%97%e6%b3%95%e9%9c%80%e8%a6%81%e7%86%9f%e7%bb%83%e6%8e%8c%e6%8f%a1%e7%9a%84%e6%a8%a1%e5%9d%97" class="anchor">🔗</a></h1><p>Option， Result， mem， ptr， vec， String， str， iter。</p>
<p>Rc， Arc， Cell， RefCell， Box</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>  <span style="color:#75715e">//char 长度都为 4 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">let</span> chars <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;你好 🦀&#34;</span>.chars().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> memory_location <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">i32</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span></code></pre></div><p>todo  Cell Vs RefCell UnsafeCell(&amp;T --&gt; &amp;mut T)</p>
<p>Cell 不能get到inner ref， 所以修改inner是ok的<br>
impl !sync for Cell <br></p>
<p>Rc vs Arc <br></p>
<p>std::ptr::NonNull<br></p>
<h2 id="optiont-会用到的api">Option<T> 会用到的API <a href="#optiont-%e4%bc%9a%e7%94%a8%e5%88%b0%e7%9a%84api" class="anchor">🔗</a></h2><p>as_ref(): Converts <code>&amp;Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code>.<code>&lt;br&gt; as_mut(): from</code>&amp;mut Option<T><code>-&gt;</code>Option&lt;&amp;mut T&gt;` <br></p>
<p>Option 与 Result 常见方法的对比: <br></p>
<table>
<thead>
<tr>
<th>Option<T></th>
<th>函数的功能</th>
<th>Result&lt;T, E&gt;</th>
<th>函数的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_some(&amp;self), is_none()</td>
<td></td>
<td>is_ok(&amp;self), is_err()</td>
<td></td>
</tr>
<tr>
<td>ok_or<E>(self, err: E) -&gt; Result&lt;T, E&gt;()</td>
<td>-&gt;Result&lt;T, E&gt;</td>
<td>ok(self) -&gt; Option<T>, err(self) -&gt; Option<E></td>
<td>Result-&gt;Option</td>
</tr>
<tr>
<td>as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;</td>
<td>&amp;Option&lt;T -&gt; Option&lt;&amp;T&gt;</td>
<td>as_ref(&amp;self) -&gt;Result&lt;&amp;T, &amp;E&gt;</td>
<td></td>
</tr>
<tr>
<td>as_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;</td>
<td>&amp;mut Option<T> -&gt; Option&lt;&amp;mut T&gt;</td>
<td>as_mut(&amp;mut self) -&gt; Result&lt;&amp;mut T, &amp;mut E&gt;</td>
<td></td>
</tr>
<tr>
<td>map&lt;U, F&gt;(self, f: F) -&gt; Option<U> where F: FnOnce(T) -&gt; U</td>
<td>consume the orignal</td>
<td>map(self, op: F)</td>
<td>Result&lt;T, E&gt; -&gt; Result&lt;U, E&gt;</td>
</tr>
<tr>
<td>as_deref(&amp;self) -&gt; Option&lt;&amp;<T as Deref>::Target&gt; where T: Deref,</td>
<td>&amp;Option&lt;T -&gt; Option&lt;&amp;T::Target&gt;</td>
<td>as_deref(&amp;self) -&gt; &lt;&amp;<T as deref>::Target, &amp;E&gt;</td>
<td>Result&lt;String, u32&gt; -&gt; Result&lt;&amp;str, &amp;u32&gt;</td>
</tr>
<tr>
<td>as_deref_mut(&amp;mut self) -&gt; Option&lt;&amp;mut <T as Deref>::Target&gt; where T: DerefMut,</td>
<td>&amp;mut Option<T> -&gt; Option&lt;&amp;mut T::Target&gt;</td>
<td>as_deref_mut(&amp;mut self)</td>
<td></td>
</tr>
<tr>
<td>expect(self, msg: &amp;str)</td>
<td>may panic</td>
<td>expect(self, msg: &amp;str) -&gt; T</td>
<td>may panic</td>
</tr>
<tr>
<td>unwrap(self) -&gt; T</td>
<td>my panic</td>
<td>unwrap(self)-&gt;T</td>
<td>may panic</td>
</tr>
<tr>
<td>unwrap_or_default(self)-&gt; T where T: Default,</td>
<td>no panic</td>
<td></td>
<td></td>
</tr>
<tr>
<td>take(&amp;mut self) -&gt; Option<T></td>
<td>leave none, return Option</td>
<td></td>
<td></td>
</tr>
<tr>
<td>replace(&amp;mut self, value: T) -&gt; Option<T></td>
<td>change and return old value</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  None,
</span></span><span style="display:flex;"><span>  Some(T),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_ref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> text: Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Some(<span style="color:#e6db74">&#34;Hello, world!&#34;</span>.to_string());
</span></span><span style="display:flex;"><span><span style="color:#75715e">// First, cast `Option&lt;String&gt;` to `Option&lt;&amp;String&gt;` with `as_ref`,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// then consume *that* with `map`, leaving `text` on the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> text_length: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> text.as_ref().map(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s.len());
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;still can print text: {text:?}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expect() <span style="color:#75715e">// panics with a provided custom message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>unwrap() <span style="color:#75715e">// panics with a generic message
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>unwrap_or(<span style="color:#e6db74">&#34;abc&#34;</span>) <span style="color:#75715e">// returns the provided default value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>ok_or() <span style="color:#75715e">//Some(v) to Ok(v), and None to Err(err)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>filter() <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>map()    <span style="color:#75715e">//  Option&lt;T&gt; to Option&lt;U&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>take()   <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>replace() <span style="color:#75715e">//
</span></span></span></code></pre></div><p>and_then()</p>
<p>take(): <br></p>
<p>deref_mut() <br></p>
<h2 id="asreft">AsRef<T> <a href="#asreft" class="anchor">🔗</a></h2><p>String -&gt; &amp;str (&quot;abc&quot;.to_string().as_ref())</p>
<h1 id="包模块可见性">包，模块，可见性 <a href="#%e5%8c%85%e6%a8%a1%e5%9d%97%e5%8f%af%e8%a7%81%e6%80%a7" class="anchor">🔗</a></h1><p>模块foo可以有2种表示： 一个名为 foo.rs 的文件; 在名为 foo 的目录，里面有一个叫 mod.rs 文件。</p>
<h1 id="stdcmd包">std::cmd包 <a href="#stdcmd%e5%8c%85" class="anchor">🔗</a></h1><p>整个逻辑只在<code>/library/core/src/cmp.rs</code>中定义清楚。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::Eq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Eq: PartialEq<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> {}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::PartialEq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> PartialEq<span style="color:#f92672">&lt;</span>Rhs <span style="color:#f92672">=</span> Self<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span> Rhs: <span style="color:#f92672">?</span>Sized,
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Required Methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eq</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Rhs</span>) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::PartialOrd 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> PartialOrd<span style="color:#f92672">&lt;</span>Rhs: <span style="color:#f92672">?</span>Sized <span style="color:#f92672">=</span> Self<span style="color:#f92672">&gt;</span>: PartialEq<span style="color:#f92672">&lt;</span>Rhs<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Required Methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">partial_cmp</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Rhs</span>) -&gt; Option<span style="color:#f92672">&lt;</span>Ordering<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::cmp::Ord
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Ord: Eq <span style="color:#f92672">+</span> PartialOrd<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Required Methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Ordering</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">min</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">clamp</span>(self, min: <span style="color:#a6e22e">Self</span>, max: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> <span style="color:#66d9ef">where</span> Self: PartialOrd<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Ordering</span> {
</span></span><span style="display:flex;"><span>    Less <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    Equal <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    Greater <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="泛型编程">泛型编程 <a href="#%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b" class="anchor">🔗</a></h1><p>是否有必要在此刻就把类型定死? <br>
通过泛型静态绑定推迟到编译期确定类型，trait obj推迟到运行期确定类型。<br></p>
<h1 id="类型的嵌套">类型的嵌套 <a href="#%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%b5%8c%e5%a5%97" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>String<span style="color:#960050;background-color:#1e0010">，</span> Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, Box<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, Unique<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> T
</span></span></code></pre></div><p><code>dyn (Fn() + Send + 'static)</code>是什么意思？<br></p>
<p>Fn() 不带参数和返回值的闭包，可以被Send到其他线程中，具有捕获变量的所有权。
’static是指没有对上下文中的非静态变量进行引用。</p>
<h1 id="any-trait"><code>Any</code> trait <a href="#any-trait" class="anchor">🔗</a></h1><p>反射。
Deref, Drop, Copy, Any trait</p>
<p>Send &amp; Sync</p>
<p>?Size</p>
<h1 id="fn-fnmut-fnonce-区别"><code>Fn FnMut FnOnce</code> 区别 <a href="#fn-fnmut-fnonce-%e5%8c%ba%e5%88%ab" class="anchor">🔗</a></h1><p><strong>闭包去实现哪种<code>Fn, FnMut, FnOnce</code>trait与move无关，与如何捕获变量无关。</strong><br>
<strong>Fn FnMut FnOnce与闭包如何使用捕获到的值有关。</strong><br></p>
<p>闭包是trait object， 也是DST类型的。
返回闭包： <code>-&gt; Box&lt;dyn Fn(i32) -&gt;i32&gt;</code></p>
<p>闭包就是捕获外部变量的结构体，加一段代码<br></p>
<p>closure 是结构体（捕获的变量）的语法糖，闭包逻辑部分在代码段中。<br>
闭包的调用： Fn::call(第一个参数就是闭包结构体...) Fn：call_</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 移走匿名结构体中变量的closure实现 FnOnce
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FnOnce::call_once(self, args: <span style="color:#a6e22e">Args</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不会移走匿名结构体中变量但修改的closure实现 FnMut
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FnMut::call_mut(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, args: <span style="color:#a6e22e">Args</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//不会修改匿名结构体中变量的closure实现 Fn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Fn: <span style="color:#a6e22e">call</span>(<span style="color:#f92672">&amp;</span>self, args: <span style="color:#a6e22e">Args</span> -&gt; <span style="color:#a6e22e">Self</span>::Output);
</span></span></code></pre></div><p>在rust中，函数和闭包都是实现了Fn、FnMut或FnOnce特质（trait）的类型。
任何实现了这三种特质其中一种的类型的对象，都是 可调用对象 ，都能像函数和闭包一样通过这样name()的形式调用，
()在rust中是一个操作符，操作符在rust中是可以重载的。
rust的操作符重载是通过实现相应的trait来实现，而()操作符的相应trait就是Fn、FnMut和FnOnce，
所以，任何实现了这三个trait中的一种的类型，其实就是重载了()操作符</p>
<h1 id="rust-生命宏-过程宏-rust中的插桩">rust 生命宏， 过程宏， rust中的插桩 <a href="#rust-%e7%94%9f%e5%91%bd%e5%ae%8f-%e8%bf%87%e7%a8%8b%e5%ae%8f-rust%e4%b8%ad%e7%9a%84%e6%8f%92%e6%a1%a9" class="anchor">🔗</a></h1><p>why 为什么需要宏？ 宏是扩展语言的一种方式，元编程。<br>
声明宏： 对代码模版做简单替换。 <code>macro_rules!</code>。 过程宏： 可以深度定制和生产代码。 <br>
利用过程宏修改ast来实现fn进入和出来时打印日志。</p>
<h1 id="子类型-类型产生器-协变逆变不变">子类型， 类型产生器， 协变，逆变，不变 <a href="#%e5%ad%90%e7%b1%bb%e5%9e%8b-%e7%b1%bb%e5%9e%8b%e4%ba%a7%e7%94%9f%e5%99%a8-%e5%8d%8f%e5%8f%98%e9%80%86%e5%8f%98%e4%b8%8d%e5%8f%98" class="anchor">🔗</a></h1><p><code>T: U , a: U, b: T</code></p>
<h1 id="t-vs-mut-t">&amp;T vs &amp;mut T <a href="#t-vs-mut-t" class="anchor">🔗</a></h1><p>&amp;T: 共享引用， &amp;mut T 独占引用<br></p>
<h1 id="rust-内存模型">rust 内存模型 <a href="#rust-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" class="anchor">🔗</a></h1><p>compare_exchange , compare_exchange_weak<br>
std::sync::atmoic, memory ordering</p>
<ul>
<li>acquire 用于load， 读</li>
<li>release 用于store，写</li>
<li>seq     相当于memory barrier</li>
</ul>
<h1 id="操作符号重载">操作符号重载 <a href="#%e6%93%8d%e4%bd%9c%e7%ac%a6%e5%8f%b7%e9%87%8d%e8%bd%bd" class="anchor">🔗</a></h1><p>rust中的操作符几乎都与一个trait相对应。解引用*x, 重载std::ops::Deref<br>
不可重载的运算符： <code>&amp;, &amp;mut</code></p>
<h1 id="哪些操作可能会ownership-move-">哪些操作可能会ownership move ？ <a href="#%e5%93%aa%e4%ba%9b%e6%93%8d%e4%bd%9c%e5%8f%af%e8%83%bd%e4%bc%9aownership-move-" class="anchor">🔗</a></h1><p>所有权，move语义，借用，生命周期的推进关系<br>
为了适应内存的ownership&amp;move语义，引入borrow &amp; reference。<br>
带来新问题是所有权和使用权分隔了，让引用和原始值的内存空间独立了。<br>
但是两者具有逻辑关系上的约束： 引用只能在原始值存在的前提下才有意义。<br>
引入生命周期lifetime到语法中。<code>'a</code>  在函数的入参和返回值之间建立生命周期约束<br>
静态生命周期 ‘static， 全局变量，静态变量，字符串字面量 , 函数指针（进程的虚拟地址空间：BSS， Data， Text， Heap(leaked)）</p>
<p>例如： 一个fn返回了引用，如果是引用fn的local变量则❌，如果是引用fn的参数，那么compiler需要知道传入的参数的存活时间是否支撑这个引用的有效性(新引用的生命周期只能是被引用值的生命周期的区间子集)。</p>
<p>Copy：复制语义非move语义。Clone用从&amp;T中创建副本T。<br>
copy是浅拷贝，是编译器自动调用。 clone是深拷贝，程序员手动调用。<br></p>
<ul>
<li>let binding</li>
<li>传参数到function</li>
<li>match 表达式</li>
<li>methods。 impl block里任何method第一个参数是self</li>
<li>closure中</li>
</ul>
<p>特殊例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> Some(String::from(<span style="color:#e6db74">&#34;hallo&#34;</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// _s 会发生绑定， 所有权移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(_s) <span style="color:#f92672">=</span> s {}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// _ 不会绑定 所有权没有移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(_) <span style="color:#f92672">=</span> s {}
</span></span></code></pre></div><h1 id="rust中的类型转换">rust中的类型转换 <a href="#rust%e4%b8%ad%e7%9a%84%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" class="anchor">🔗</a></h1><pre><code>as 转换。
        300_i32 as i8 == 44
tryinto转换, use std::convert::TryInto。
as， tryinto 只能运用在数值类型上。
</code></pre>
<p><strong>通用转换。<code>unsafe{}</code>, <code>Transmutes</code>。</strong><code>std::mem::transmute&lt;T, U&gt; </code>将T转为U类型。<code>std::mem::transmute_copy</code>&lt;T, U&gt;</p>
<h1 id="rust源码库中的重导出">rust源码库中的重导出 <a href="#rust%e6%ba%90%e7%a0%81%e5%ba%93%e4%b8%ad%e7%9a%84%e9%87%8d%e5%af%bc%e5%87%ba" class="anchor">🔗</a></h1><p>疑问：std::ops::Add or core::ops::Add, std::ops::Fn, core::ops::Fn ? 🤔️
解答： <a href="https://github.com/rust-lang/rust/blob/5807fbbfde3ad04820f6fa0269711c81538057ec/src/libstd/lib.rs#L332-L333" target="_blank" rel="noopener">std reexports everything from core, via pub use</a></p>
<h1 id="cargo">cargo <a href="#cargo" class="anchor">🔗</a></h1><p>cargo install 安装二进制crate。 可执行的二进制文件默认存放在A=$HOME/.cargo/bin下面。
如果A在$PATH下，那么cargo install后的二进制可直接在命令行中运行。</p>
<p>IDE： vscode
插件： rust-analyzer（用）, Rust(别用, 与rust-analyzer有冲突)。</p>
<p>rustup 管理rust编程环境。
rustup which rustc 查看rustc的位置
rustup component add rust-src 下载rust源码。</p>
<p>数组array的类型： 元素类型+数组长度（长度也是类型的一部分）[Type; N] , [1, 2, 3], [val; n]。</p>
<p>全局变量：编译期初始化的全局变量。 const ， static；运行期初始化的全局变量。lazy_static, Box::leak()</p>
<h1 id="在vscode下配置rust项目的阅读和debug">在vscode下配置rust项目的阅读和debug <a href="#%e5%9c%a8vscode%e4%b8%8b%e9%85%8d%e7%bd%aerust%e9%a1%b9%e7%9b%ae%e7%9a%84%e9%98%85%e8%af%bb%e5%92%8cdebug" class="anchor">🔗</a></h1><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>rust<span style="color:#f92672">-</span>analyzer failed to load workspace: <span style="color:#a6e22e">Failed</span> to read Cargo metadata from Cargo.toml file
</span></span><span style="display:flex;"><span>solved<span style="color:#960050;background-color:#1e0010">：</span>Update the Rust to satisfy the new edition <span style="color:#ae81ff">2021.</span>
</span></span><span style="display:flex;"><span>rustup default nightly <span style="color:#f92672">&amp;&amp;</span> rustup update
</span></span></code></pre></div>
    </div>

    
        <div class="tags">
            
                <a href="http://brettkk.github.io/tags/rust">rust</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <script src="https://utteranc.es/client.js"
repo="brettKK/brettkk.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>  

    <div class="copyright">
    
       © Copyright 
       2023 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-cactus-plus'>nodejh</a>
      </div>
    
</footer>




  </body>
</html>
